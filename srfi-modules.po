#. extracted from /home/bear/work/guile/doc/guile/en/srfi-modules.texi
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-07 12:37+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: Translate Toolkit 2.2.5\n"

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:6
msgid ""
"@c -*-texinfo-*-\n"
"@c This is part of the GNU Guile Reference Manual.\n"
"@c Copyright (C) 1996, 1997, 2000-2004, 2006, 2007-2014, 2017\n"
"@c   Free Software Foundation, Inc.\n"
"@c See the file guile.texi for copying conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:10
msgid ""
"@node SRFI Support\n"
"@section SRFI Support Modules\n"
"@cindex SRFI"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:14
msgid ""
"SRFI is an acronym for Scheme Request For Implementation.  The SRFI\n"
"documents define a lot of syntactic and procedure extensions to standard\n"
"Scheme as defined in R5RS."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:20
msgid ""
"Guile has support for a number of SRFIs.  This chapter gives an overview\n"
"over the available SRFIs and some usage hints.  For complete\n"
"documentation, design rationales and further examples, we advise you to\n"
"get the relevant SRFI documents from the SRFI home page\n"
"@url{http://srfi.schemers.org/}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:67
msgid ""
"@menu\n"
"* About SRFI Usage::            What to know about Guile's SRFI support.\n"
"* SRFI-0::                      cond-expand\n"
"* SRFI-1::                      List library.\n"
"* SRFI-2::                      and-let*.\n"
"* SRFI-4::                      Homogeneous numeric vector datatypes.\n"
"* SRFI-6::                      Basic String Ports.\n"
"* SRFI-8::                      receive.\n"
"* SRFI-9::                      define-record-type.\n"
"* SRFI-10::                     Hash-Comma Reader Extension.\n"
"* SRFI-11::                     let-values and let*-values.\n"
"* SRFI-13::                     String library.\n"
"* SRFI-14::                     Character-set library.\n"
"* SRFI-16::                     case-lambda\n"
"* SRFI-17::                     Generalized set!\n"
"* SRFI-18::                     Multithreading support\n"
"* SRFI-19::                     Time/Date library.\n"
"* SRFI-23::                     Error reporting\n"
"* SRFI-26::                     Specializing parameters\n"
"* SRFI-27::                     Sources of Random Bits\n"
"* SRFI-28::                     Basic format strings.\n"
"* SRFI-30::                     Nested multi-line block comments\n"
"* SRFI-31::                     A special form `rec' for recursive "
"evaluation\n"
"* SRFI-34::                     Exception handling.\n"
"* SRFI-35::                     Conditions.\n"
"* SRFI-37::                     args-fold program argument processor\n"
"* SRFI-38::                     External Representation for Data With Shared "
"Structure\n"
"* SRFI-39::                     Parameter objects\n"
"* SRFI-41::                     Streams.\n"
"* SRFI-42::                     Eager comprehensions\n"
"* SRFI-43::                     Vector Library.\n"
"* SRFI-45::                     Primitives for expressing iterative lazy "
"algorithms\n"
"* SRFI-46::                     Basic syntax-rules Extensions.\n"
"* SRFI-55::                     Requiring Features.\n"
"* SRFI-60::                     Integers as bits.\n"
"* SRFI-61::                     A more general `cond' clause\n"
"* SRFI-62::                     S-expression comments.\n"
"* SRFI-64::                     A Scheme API for test suites.\n"
"* SRFI-67::                     Compare procedures\n"
"* SRFI-69::                     Basic hash tables.\n"
"* SRFI-87::                     => in case clauses.\n"
"* SRFI-88::                     Keyword objects.\n"
"* SRFI-98::                     Accessing environment variables.\n"
"* SRFI-105::                    Curly-infix expressions.\n"
"* SRFI-111::                    Boxes.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:71
msgid ""
"@node About SRFI Usage\n"
"@subsection About SRFI Usage"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:73
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:73"
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:79
msgid ""
"SRFI support in Guile is currently implemented partly in the core\n"
"library, and partly as add-on modules.  That means that some SRFIs are\n"
"automatically available when the interpreter is started, whereas the\n"
"other SRFIs require you to use the appropriate support module\n"
"explicitly."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:95
msgid ""
"There are several reasons for this inconsistency.  First, the feature\n"
"checking syntactic form @code{cond-expand} (@pxref{SRFI-0}) must be\n"
"available immediately, because it must be there when the user wants to\n"
"check for the Scheme implementation, that is, before she can know that\n"
"it is safe to use @code{use-modules} to load SRFI support modules.  The\n"
"second reason is that some features defined in SRFIs had been\n"
"implemented in Guile before the developers started to add SRFI\n"
"implementations as modules (for example SRFI-13 (@pxref{SRFI-13})).  In\n"
"the future, it is possible that SRFIs in the core library might be\n"
"factored out into separate modules, requiring explicit module loading\n"
"when they are needed.  So you should be prepared to have to use\n"
"@code{use-modules} someday in the future to access SRFI-13 bindings.  If\n"
"you want, you can do that already.  We have included the module\n"
"@code{(srfi srfi-13)} in the distribution, which currently does nothing,\n"
"but ensures that you can write future-safe code."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:101
msgid ""
"Generally, support for a specific SRFI is made available by using\n"
"modules named @code{(srfi srfi-@var{number})}, where @var{number} is the\n"
"number of the SRFI needed.  Another possibility is to use the command\n"
"line option @code{--use-srfi}, which will load the necessary modules\n"
"automatically (@pxref{Invoking Guile})."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:106
msgid ""
"@node SRFI-0\n"
"@subsection SRFI-0 - cond-expand\n"
"@cindex SRFI-0"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:111
msgid ""
"This SRFI lets a portable Scheme program test for the presence of\n"
"certain features, and adapt itself by using different blocks of code,\n"
"or fail if the necessary features are not available.  There's no\n"
"module to load, this is in the Guile core."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:115
msgid ""
"A program designed only for Guile will generally not need this\n"
"mechanism, such a program can of course directly use the various\n"
"documented parts of Guile."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:120
msgid ""
"@deffn syntax cond-expand (feature body@dots{}) @dots{}\n"
"Expand to the @var{body} of the first clause whose @var{feature}\n"
"specification is satisfied.  It is an error if no @var{feature} is\n"
"satisfied."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:125
msgid ""
"Features are symbols such as @code{srfi-1}, and a feature\n"
"specification can use @code{and}, @code{or} and @code{not} forms to\n"
"test combinations.  The last clause can be an @code{else}, to be used\n"
"if no other passes."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:128
msgid ""
"For example, define a private version of @code{alist-cons} if SRFI-1\n"
"is not available."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:136
msgid ""
"@example\n"
"(cond-expand (srfi-1\n"
"              )\n"
"             (else\n"
"              (define (alist-cons key val alist)\n"
"                (cons (cons key val) alist))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:140
msgid ""
"Or demand a certain set of SRFIs (list operations, string ports,\n"
"@code{receive} and string operations), failing if they're not\n"
"available."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:146
msgid ""
"@example\n"
"(cond-expand ((and srfi-1 srfi-6 srfi-8 srfi-13)\n"
"              ))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:149
msgid ""
"@noindent\n"
"The Guile core has the following features,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:171
msgid ""
"@example\n"
"guile\n"
"guile-2  ;; starting from Guile 2.x\n"
"guile-2.2  ;; starting from Guile 2.2\n"
"r5rs\n"
"srfi-0\n"
"srfi-4\n"
"srfi-6\n"
"srfi-13\n"
"srfi-14\n"
"srfi-16\n"
"srfi-23\n"
"srfi-30\n"
"srfi-39\n"
"srfi-46\n"
"srfi-55\n"
"srfi-61\n"
"srfi-62\n"
"srfi-87\n"
"srfi-105\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:174
msgid ""
"Other SRFI feature symbols are defined once their code has been loaded\n"
"with @code{use-modules}, since only then are their bindings available."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:178
msgid ""
"The @samp{--use-srfi} command line option (@pxref{Invoking Guile}) is\n"
"a good way to load SRFIs to satisfy @code{cond-expand} when running a\n"
"portable program."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:183
msgid ""
"Testing the @code{guile} feature allows a program to adapt itself to\n"
"the Guile module system, but still run on other Scheme systems.  For\n"
"example the following demands SRFI-8 (@code{receive}), but also knows\n"
"how to load it with the Guile mechanism."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:190
msgid ""
"@example\n"
"(cond-expand (srfi-8\n"
"              )\n"
"             (guile\n"
"              (use-modules (srfi srfi-8))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:197
msgid ""
"@cindex @code{guile-2} SRFI-0 feature\n"
"@cindex portability between 2.0 and older versions\n"
"Likewise, testing the @code{guile-2} feature allows code to be portable\n"
"between Guile 2.@var{x} and previous versions of Guile.  For instance, it\n"
"makes it possible to write code that accounts for Guile 2.@var{x}'s compiler,"
"\n"
"yet be correctly interpreted on 1.8 and earlier versions:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:207
msgid ""
"@example\n"
"(cond-expand (guile-2 (eval-when (compile)\n"
"                        ;; This must be evaluated at compile time.\n"
"                        (fluid-set! current-reader my-reader)))\n"
"             (guile\n"
"                      ;; Earlier versions of Guile do not have a\n"
"                      ;; separate compilation phase.\n"
"                      (fluid-set! current-reader my-reader)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:211
msgid ""
"It should be noted that @code{cond-expand} is separate from the\n"
"@code{*features*} mechanism (@pxref{Feature Tracking}), feature\n"
"symbols in one are unrelated to those in the other."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:217
msgid ""
"@node SRFI-1\n"
"@subsection SRFI-1 - List library\n"
"@cindex SRFI-1\n"
"@cindex list"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:219
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:219"
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:223
msgid ""
"The list library defined in SRFI-1 contains a lot of useful list\n"
"processing procedures for construction, examining, destructuring and\n"
"manipulating lists and pairs."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:230
msgid ""
"Since SRFI-1 also defines some procedures which are already contained\n"
"in R5RS and thus are supported by the Guile core library, some list\n"
"and pair procedures which appear in the SRFI-1 document may not appear\n"
"in this section.  So when looking for a particular list/pair\n"
"processing procedure, you should also have a look at the sections\n"
"@ref{Lists} and @ref{Pairs}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:243
msgid ""
"@menu\n"
"* SRFI-1 Constructors::         Constructing new lists.\n"
"* SRFI-1 Predicates::           Testing list for specific properties.\n"
"* SRFI-1 Selectors::            Selecting elements from lists.\n"
"* SRFI-1 Length Append etc::    Length calculation and list appending.\n"
"* SRFI-1 Fold and Map::         Higher-order list processing.\n"
"* SRFI-1 Filtering and Partitioning::  Filter lists based on predicates.\n"
"* SRFI-1 Searching::            Search for elements.\n"
"* SRFI-1 Deleting::             Delete elements from lists.\n"
"* SRFI-1 Association Lists::    Handle association lists.\n"
"* SRFI-1 Set Operations::       Use lists for representing sets.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:247
msgid ""
"@node SRFI-1 Constructors\n"
"@subsubsection Constructors\n"
"@cindex list constructor"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:249
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:249"
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:252
msgid ""
"New lists can be constructed by calling one of the following\n"
"procedures."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:257
msgid ""
"@deffn {Scheme Procedure} xcons d a\n"
"Like @code{cons}, but with interchanged arguments.  Useful mostly when\n"
"passed to higher-order procedures.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:264
msgid ""
"@deffn {Scheme Procedure} list-tabulate n init-proc\n"
"Return an @var{n}-element list, where each list element is produced by\n"
"applying the procedure @var{init-proc} to the corresponding list\n"
"index.  The order in which @var{init-proc} is applied to the indices\n"
"is not specified.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:267
msgid ""
"@deffn {Scheme Procedure} list-copy lst\n"
"Return a new list containing the elements of the list @var{lst}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:273
msgid ""
"This function differs from the core @code{list-copy} (@pxref{List\n"
"Constructors}) in accepting improper lists too.  And if @var{lst} is\n"
"not a pair at all then it's treated as the final tail of an improper\n"
"list and simply returned.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:278
msgid ""
"@deffn {Scheme Procedure} circular-list elt1 elt2 @dots{}\n"
"Return a circular list containing the given arguments @var{elt1}\n"
"@var{elt2} @dots{}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:283
msgid ""
"@deffn {Scheme Procedure} iota count [start step]\n"
"Return a list containing @var{count} numbers, starting from\n"
"@var{start} and adding @var{step} each time.  The default @var{start}\n"
"is 0, the default @var{step} is 1.  For example,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:288
msgid ""
"@example\n"
"(iota 6)        @result{} (0 1 2 3 4 5)\n"
"(iota 4 2.5 -2) @result{} (2.5 0.5 -1.5 -3.5)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:292
msgid ""
"This function takes its name from the corresponding primitive in the\n"
"APL language.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:297
msgid ""
"@node SRFI-1 Predicates\n"
"@subsubsection Predicates\n"
"@cindex list predicate"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:299
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:299"
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:301
msgid "The procedures in this section test specific properties of lists."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:306
msgid ""
"@deffn {Scheme Procedure} proper-list? obj\n"
"Return @code{#t} if @var{obj} is a proper list, or @code{#f}\n"
"otherwise.  This is the same as the core @code{list?} (@pxref{List\n"
"Predicates})."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:309
msgid ""
"A proper list is a list which ends with the empty list @code{()} in\n"
"the usual way.  The empty list @code{()} itself is a proper list too."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:315
msgid ""
"@example\n"
"(proper-list? '(1 2 3))  @result{} #t\n"
"(proper-list? '())       @result{} #t\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:319
msgid ""
"@deffn {Scheme Procedure} circular-list? obj\n"
"Return @code{#t} if @var{obj} is a circular list, or @code{#f}\n"
"otherwise."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:324
msgid ""
"A circular list is a list where at some point the @code{cdr} refers\n"
"back to a previous pair in the list (either the start or some later\n"
"point), so that following the @code{cdr}s takes you around in a\n"
"circle, with no end."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:332
msgid ""
"@example\n"
"(define x (list 1 2 3 4))\n"
"(set-cdr! (last-pair x) (cddr x))\n"
"x @result{} (1 2 3 4 3 4 3 4 ...)\n"
"(circular-list? x)  @result{} #t\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:336
msgid ""
"@deffn {Scheme Procedure} dotted-list? obj\n"
"Return @code{#t} if @var{obj} is a dotted list, or @code{#f}\n"
"otherwise."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:340
msgid ""
"A dotted list is a list where the @code{cdr} of the last pair is not\n"
"the empty list @code{()}.  Any non-pair @var{obj} is also considered a\n"
"dotted list, with length zero."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:346
msgid ""
"@example\n"
"(dotted-list? '(1 2 . 3))  @result{} #t\n"
"(dotted-list? 99)          @result{} #t\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:352
msgid ""
"It will be noted that any Scheme object passes exactly one of the\n"
"above three tests @code{proper-list?}, @code{circular-list?} and\n"
"@code{dotted-list?}.  Non-lists are @code{dotted-list?}, finite lists\n"
"are either @code{proper-list?} or @code{dotted-list?}, and infinite\n"
"lists are @code{circular-list?}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:361
msgid ""
"@sp 1\n"
"@deffn {Scheme Procedure} null-list? lst\n"
"Return @code{#t} if @var{lst} is the empty list @code{()}, @code{#f}\n"
"otherwise.  If something else than a proper or circular list is passed\n"
"as @var{lst}, an error is signalled.  This procedure is recommended\n"
"for checking for the end of a list in contexts where dotted lists are\n"
"not allowed.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:368
msgid ""
"@deffn {Scheme Procedure} not-pair? obj\n"
"Return @code{#t} is @var{obj} is not a pair, @code{#f} otherwise.\n"
"This is shorthand notation @code{(not (pair? @var{obj}))} and is\n"
"supposed to be used for end-of-list checking in contexts where dotted\n"
"lists are allowed.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:376
msgid ""
"@deffn {Scheme Procedure} list= elt= list1 @dots{}\n"
"Return @code{#t} if all argument lists are equal, @code{#f} otherwise.\n"
"List equality is determined by testing whether all lists have the same\n"
"length and the corresponding elements are equal in the sense of the\n"
"equality predicate @var{elt=}.  If no or only one list is given,\n"
"@code{#t} is returned.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:381
msgid ""
"@node SRFI-1 Selectors\n"
"@subsubsection Selectors\n"
"@cindex list selector"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:383
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:383"
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:396
msgid ""
"@deffn {Scheme Procedure} first pair\n"
"@deffnx {Scheme Procedure} second pair\n"
"@deffnx {Scheme Procedure} third pair\n"
"@deffnx {Scheme Procedure} fourth pair\n"
"@deffnx {Scheme Procedure} fifth pair\n"
"@deffnx {Scheme Procedure} sixth pair\n"
"@deffnx {Scheme Procedure} seventh pair\n"
"@deffnx {Scheme Procedure} eighth pair\n"
"@deffnx {Scheme Procedure} ninth pair\n"
"@deffnx {Scheme Procedure} tenth pair\n"
"These are synonyms for @code{car}, @code{cadr}, @code{caddr}, @dots{}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:400
msgid ""
"@deffn {Scheme Procedure} car+cdr pair\n"
"Return two values, the @sc{car} and the @sc{cdr} of @var{pair}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:404
msgid ""
"@deffn {Scheme Procedure} take lst i\n"
"@deffnx {Scheme Procedure} take! lst i\n"
"Return a list containing the first @var{i} elements of @var{lst}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:408
msgid ""
"@code{take!} may modify the structure of the argument list @var{lst}\n"
"in order to produce the result.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:413
msgid ""
"@deffn {Scheme Procedure} drop lst i\n"
"Return a list containing all but the first @var{i} elements of\n"
"@var{lst}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:418
msgid ""
"@deffn {Scheme Procedure} take-right lst i\n"
"Return a list containing the @var{i} last elements of @var{lst}.\n"
"The return shares a common tail with @var{lst}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:423
msgid ""
"@deffn {Scheme Procedure} drop-right lst i\n"
"@deffnx {Scheme Procedure} drop-right! lst i\n"
"Return a list containing all but the @var{i} last elements of\n"
"@var{lst}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:428
msgid ""
"@code{drop-right} always returns a new list, even when @var{i} is\n"
"zero.  @code{drop-right!} may modify the structure of the argument\n"
"list @var{lst} in order to produce the result.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:433
msgid ""
"@deffn {Scheme Procedure} split-at lst i\n"
"@deffnx {Scheme Procedure} split-at! lst i\n"
"Return two values, a list containing the first @var{i} elements of the\n"
"list @var{lst} and a list containing the remaining elements."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:437
msgid ""
"@code{split-at!} may modify the structure of the argument list\n"
"@var{lst} in order to produce the result.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:441
msgid ""
"@deffn {Scheme Procedure} last lst\n"
"Return the last element of the non-empty, finite list @var{lst}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:445
msgid ""
"@node SRFI-1 Length Append etc\n"
"@subsubsection Length, Append, Concatenate, etc."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:447
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:447"
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:452
msgid ""
"@deffn {Scheme Procedure} length+ lst\n"
"Return the length of the argument list @var{lst}.  When @var{lst} is a\n"
"circular list, @code{#f} is returned.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:456
msgid ""
"@deffn {Scheme Procedure} concatenate list-of-lists\n"
"@deffnx {Scheme Procedure} concatenate! list-of-lists\n"
"Construct a list by appending all lists in @var{list-of-lists}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:459
msgid ""
"@code{concatenate!} may modify the structure of the given lists in\n"
"order to produce the result."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:465
msgid ""
"@code{concatenate} is the same as @code{(apply append\n"
"@var{list-of-lists})}.  It exists because some Scheme implementations\n"
"have a limit on the number of arguments a function takes, which the\n"
"@code{apply} might exceed.  In Guile there is no such limit.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:471
msgid ""
"@deffn {Scheme Procedure} append-reverse rev-head tail\n"
"@deffnx {Scheme Procedure} append-reverse! rev-head tail\n"
"Reverse @var{rev-head}, append @var{tail} to it, and return the\n"
"result.  This is equivalent to @code{(append (reverse @var{rev-head})\n"
"@var{tail})}, but its implementation is more efficient."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:475
msgid ""
"@example\n"
"(append-reverse '(1 2 3) '(4 5 6)) @result{} (3 2 1 4 5 6)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:479
msgid ""
"@code{append-reverse!} may modify @var{rev-head} in order to produce\n"
"the result.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:486
msgid ""
"@deffn {Scheme Procedure} zip lst1 lst2 @dots{}\n"
"Return a list as long as the shortest of the argument lists, where\n"
"each element is a list.  The first list contains the first elements of\n"
"the argument lists, the second list contains the second elements, and\n"
"so on.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:497
msgid ""
"@deffn {Scheme Procedure} unzip1 lst\n"
"@deffnx {Scheme Procedure} unzip2 lst\n"
"@deffnx {Scheme Procedure} unzip3 lst\n"
"@deffnx {Scheme Procedure} unzip4 lst\n"
"@deffnx {Scheme Procedure} unzip5 lst\n"
"@code{unzip1} takes a list of lists, and returns a list containing the\n"
"first elements of each list, @code{unzip2} returns two lists, the\n"
"first containing the first elements of each lists and the second\n"
"containing the second elements of each lists, and so on.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:501
msgid ""
"@deffn {Scheme Procedure} count pred lst1 lst2 @dots{}\n"
"Return a count of the number of times @var{pred} returns true when\n"
"called on elements from the given lists."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:506
msgid ""
"@var{pred} is called with @var{N} parameters @code{(@var{pred}\n"
"@var{elem1} @dots{} @var{elemN} )}, each element being from the\n"
"corresponding list.  The first call is with the first element of each\n"
"list, the second with the second element from each, and so on."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:510
msgid ""
"Counting stops when the end of the shortest list is reached.  At least\n"
"one list must be non-circular.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:516
msgid ""
"@node SRFI-1 Fold and Map\n"
"@subsubsection Fold, Unfold & Map\n"
"@cindex list fold\n"
"@cindex list map"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:518
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:518"
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:523
msgid ""
"@deffn {Scheme Procedure} fold proc init lst1 lst2 @dots{}\n"
"@deffnx {Scheme Procedure} fold-right proc init lst1 lst2 @dots{}\n"
"Apply @var{proc} to the elements of @var{lst1} @var{lst2} @dots{} to\n"
"build a result, and return that result."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:529
msgid ""
"Each @var{proc} call is @code{(@var{proc} @var{elem1} @var{elem2}\n"
"@dots{}  @var{previous})}, where @var{elem1} is from @var{lst1},\n"
"@var{elem2} is from @var{lst2}, and so on.  @var{previous} is the return\n"
"from the previous call to @var{proc}, or the given @var{init} for the\n"
"first call.  If any list is empty, just @var{init} is returned."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:532
msgid ""
"@code{fold} works through the list elements from first to last.  The\n"
"following shows a list reversal and the calls it makes,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:535
msgid ""
"@example\n"
"(fold cons '() '(1 2 3))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:541
msgid ""
"(cons 1 '())\n"
"(cons 2 '(1))\n"
"(cons 3 '(2 1)\n"
"@result{} (3 2 1)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:545
msgid ""
"@code{fold-right} works through the list elements from last to first,\n"
"ie.@: from the right.  So for example the following finds the longest\n"
"string, and the last among equal longest,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:555
msgid ""
"@example\n"
"(fold-right (lambda (str prev)\n"
"              (if (> (string-length str) (string-length prev))\n"
"                  str\n"
"                  prev))\n"
"            \"\"\n"
"            '(\"x\" \"abc\" \"xyz\" \"jk\"))\n"
"@result{} \"xyz\"\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:561
msgid ""
"If @var{lst1} @var{lst2} @dots{} have different lengths, @code{fold}\n"
"stops when the end of the shortest is reached; @code{fold-right}\n"
"commences at the last element of the shortest.  Ie.@: elements past the\n"
"length of the shortest are ignored in the other @var{lst}s.  At least\n"
"one @var{lst} must be non-circular."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:565
msgid ""
"@code{fold} should be preferred over @code{fold-right} if the order of\n"
"processing doesn't matter, or can be arranged either way, since\n"
"@code{fold} is a little more efficient."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:570
msgid ""
"The way @code{fold} builds a result from iterating is quite general,\n"
"it can do more than other iterations like say @code{map} or\n"
"@code{filter}.  The following for example removes adjacent duplicate\n"
"elements from a list,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:582
msgid ""
"@example\n"
"(define (delete-adjacent-duplicates lst)\n"
"  (fold-right (lambda (elem ret)\n"
"                (if (equal? elem (first ret))\n"
"                    ret\n"
"                    (cons elem ret)))\n"
"              (list (last lst))\n"
"              lst))\n"
"(delete-adjacent-duplicates '(1 2 3 3 4 4 4 5))\n"
"@result{} (1 2 3 4 5)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:588
msgid ""
"Clearly the same sort of thing can be done with a @code{for-each} and\n"
"a variable in which to build the result, but a self-contained\n"
"@var{proc} can be re-used in multiple contexts, where a\n"
"@code{for-each} would have to be written out each time.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:594
msgid ""
"@deffn {Scheme Procedure} pair-fold proc init lst1 lst2 @dots{}\n"
"@deffnx {Scheme Procedure} pair-fold-right proc init lst1 lst2 @dots{}\n"
"The same as @code{fold} and @code{fold-right}, but apply @var{proc} to\n"
"the pairs of the lists instead of the list elements.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:600
msgid ""
"@deffn {Scheme Procedure} reduce proc default lst\n"
"@deffnx {Scheme Procedure} reduce-right proc default lst\n"
"@code{reduce} is a variant of @code{fold}, where the first call to\n"
"@var{proc} is on two elements from @var{lst}, rather than one element\n"
"and a given initial value."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:605
msgid ""
"If @var{lst} is empty, @code{reduce} returns @var{default} (this is\n"
"the only use for @var{default}).  If @var{lst} has just one element\n"
"then that's the return value.  Otherwise @var{proc} is called on the\n"
"elements of @var{lst}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:611
msgid ""
"Each @var{proc} call is @code{(@var{proc} @var{elem} @var{previous})},\n"
"where @var{elem} is from @var{lst} (the second and subsequent elements\n"
"of @var{lst}), and @var{previous} is the return from the previous call\n"
"to @var{proc}.  The first element of @var{lst} is the @var{previous}\n"
"for the first call to @var{proc}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:615
msgid ""
"For example, the following adds a list of numbers, the calls made to\n"
"@code{+} are shown.  (Of course @code{+} accepts multiple arguments\n"
"and can add a list directly, with @code{apply}.)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:618
msgid ""
"@example\n"
"(reduce + 0 '(5 6 7)) @result{} 18"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:622
msgid ""
"(+ 6 5)  @result{} 11\n"
"(+ 7 11) @result{} 18\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:627
msgid ""
"@code{reduce} can be used instead of @code{fold} where the @var{init}\n"
"value is an ``identity'', meaning a value which under @var{proc}\n"
"doesn't change the result, in this case 0 is an identity since\n"
"@code{(+ 5 0)} is just 5.  @code{reduce} avoids that unnecessary call."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:632
msgid ""
"@code{reduce-right} is a similar variation on @code{fold-right},\n"
"working from the end (ie.@: the right) of @var{lst}.  The last element\n"
"of @var{lst} is the @var{previous} for the first call to @var{proc},\n"
"and the @var{elem} values go from the second last."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:637
msgid ""
"@code{reduce} should be preferred over @code{reduce-right} if the\n"
"order of processing doesn't matter, or can be arranged either way,\n"
"since @code{reduce} is a little more efficient.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:640
msgid ""
"@deffn {Scheme Procedure} unfold p f g seed [tail-gen]\n"
"@code{unfold} is defined as follows:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:647
msgid ""
"@lisp\n"
"(unfold p f g seed) =\n"
"   (if (p seed) (tail-gen seed)\n"
"       (cons (f seed)\n"
"             (unfold p f g (g seed))))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:651
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:651"
msgid ""
"@table @var\n"
"@item p\n"
"Determines when to stop unfolding."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:654
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:654"
msgid ""
"@item f\n"
"Maps each seed value to the corresponding list element."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:657
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:657"
msgid ""
"@item g\n"
"Maps each seed value to next seed value."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:660
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:660"
msgid ""
"@item seed\n"
"The state value for the unfold."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:664
msgid ""
"@item tail-gen\n"
"Creates the tail of the list; defaults to @code{(lambda (x) '())}.\n"
"@end table"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:669
msgid ""
"@var{g} produces a series of seed values, which are mapped to list\n"
"elements by @var{f}.  These elements are put into a list in\n"
"left-to-right order, and @var{p} tells when to stop unfolding.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:672
msgid ""
"@deffn {Scheme Procedure} unfold-right p f g seed [tail]\n"
"Construct a list with the following loop."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:679
msgid ""
"@lisp\n"
"(let lp ((seed seed) (lis tail))\n"
"   (if (p seed) lis\n"
"       (lp (g seed)\n"
"           (cons (f seed) lis))))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:683
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:683"
msgid ""
"@table @var\n"
"@item p\n"
"Determines when to stop unfolding."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:686
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:686"
msgid ""
"@item f\n"
"Maps each seed value to the corresponding list element."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:689
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:689"
msgid ""
"@item g\n"
"Maps each seed value to next seed value."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:692
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:692"
msgid ""
"@item seed\n"
"The state value for the unfold."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:696
msgid ""
"@item tail\n"
"The tail of the list; defaults to @code{'()}.\n"
"@end table"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:698
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:698"
msgid "@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:707
msgid ""
"@deffn {Scheme Procedure} map f lst1 lst2 @dots{}\n"
"Map the procedure over the list(s) @var{lst1}, @var{lst2}, @dots{} and\n"
"return a list containing the results of the procedure applications.\n"
"This procedure is extended with respect to R5RS, because the argument\n"
"lists may have different lengths.  The result list will have the same\n"
"length as the shortest argument lists.  The order in which @var{f}\n"
"will be applied to the list element(s) is not specified.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:715
msgid ""
"@deffn {Scheme Procedure} for-each f lst1 lst2 @dots{}\n"
"Apply the procedure @var{f} to each pair of corresponding elements of\n"
"the list(s) @var{lst1}, @var{lst2}, @dots{}.  The return value is not\n"
"specified.  This procedure is extended with respect to R5RS, because\n"
"the argument lists may have different lengths.  The shortest argument\n"
"list determines the number of times @var{f} is called.  @var{f} will\n"
"be applied to the list elements in left-to-right order."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:717
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:717"
msgid "@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:721
msgid ""
"@deffn {Scheme Procedure} append-map f lst1 lst2 @dots{}\n"
"@deffnx {Scheme Procedure} append-map! f lst1 lst2 @dots{}\n"
"Equivalent to"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:725
msgid ""
"@lisp\n"
"(apply append (map f clist1 clist2 ...))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:727
msgid "and"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:731
msgid ""
"@lisp\n"
"(apply append! (map f clist1 clist2 ...))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:737
msgid ""
"Map @var{f} over the elements of the lists, just as in the @code{map}\n"
"function. However, the results of the applications are appended\n"
"together to make the final result. @code{append-map} uses\n"
"@code{append} to append the results together; @code{append-map!} uses\n"
"@code{append!}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:741
msgid ""
"The dynamic order in which the various applications of @var{f} are\n"
"made is not specified.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:746
msgid ""
"@deffn {Scheme Procedure} map! f lst1 lst2 @dots{}\n"
"Linear-update variant of @code{map} -- @code{map!} is allowed, but not\n"
"required, to alter the cons cells of @var{lst1} to construct the\n"
"result list."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:751
msgid ""
"The dynamic order in which the various applications of @var{f} are\n"
"made is not specified. In the n-ary case, @var{lst2}, @var{lst3},\n"
"@dots{} must have at least as many elements as @var{lst1}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:757
msgid ""
"@deffn {Scheme Procedure} pair-for-each f lst1 lst2 @dots{}\n"
"Like @code{for-each}, but applies the procedure @var{f} to the pairs\n"
"from which the argument lists are constructed, instead of the list\n"
"elements.  The return value is not specified.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:762
msgid ""
"@deffn {Scheme Procedure} filter-map f lst1 lst2 @dots{}\n"
"Like @code{map}, but only results from the applications of @var{f}\n"
"which are true are saved in the result list.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:768
msgid ""
"@node SRFI-1 Filtering and Partitioning\n"
"@subsubsection Filtering and Partitioning\n"
"@cindex list filter\n"
"@cindex list partition"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:770
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:770"
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:775
msgid ""
"Filtering means to collect all elements from a list which satisfy a\n"
"specific condition.  Partitioning a list means to make two groups of\n"
"list elements, one which contains the elements satisfying a condition,\n"
"and the other for the elements which don't."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:778
msgid ""
"The @code{filter} and @code{filter!} functions are implemented in the\n"
"Guile core, @xref{List Modification}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:783
msgid ""
"@deffn {Scheme Procedure} partition pred lst\n"
"@deffnx {Scheme Procedure} partition! pred lst\n"
"Split @var{lst} into those elements which do and don't satisfy the\n"
"predicate @var{pred}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:787
msgid ""
"The return is two values (@pxref{Multiple Values}), the first being a\n"
"list of all elements from @var{lst} which satisfy @var{pred}, the\n"
"second a list of those which do not."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:791
msgid ""
"The elements in the result lists are in the same order as in @var{lst}\n"
"but the order in which the calls @code{(@var{pred} elem)} are made on\n"
"the list elements is unspecified."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:796
msgid ""
"@code{partition} does not change @var{lst}, but one of the returned\n"
"lists may share a tail with it.  @code{partition!} may modify\n"
"@var{lst} to construct its return.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:803
msgid ""
"@deffn {Scheme Procedure} remove pred lst\n"
"@deffnx {Scheme Procedure} remove! pred lst\n"
"Return a list containing all elements from @var{lst} which do not\n"
"satisfy the predicate @var{pred}.  The elements in the result list\n"
"have the same order as in @var{lst}.  The order in which @var{pred} is\n"
"applied to the list elements is not specified."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:807
msgid ""
"@code{remove!} is allowed, but not required to modify the structure of\n"
"the input list.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:812
msgid ""
"@node SRFI-1 Searching\n"
"@subsubsection Searching\n"
"@cindex list search"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:814
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:814"
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:818
msgid ""
"The procedures for searching elements in lists either accept a\n"
"predicate or a comparison object for determining which elements are to\n"
"be searched."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:823
msgid ""
"@deffn {Scheme Procedure} find pred lst\n"
"Return the first element of @var{lst} which satisfies the predicate\n"
"@var{pred} and @code{#f} if no such element is found.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:828
msgid ""
"@deffn {Scheme Procedure} find-tail pred lst\n"
"Return the first pair of @var{lst} whose @sc{car} satisfies the\n"
"predicate @var{pred} and @code{#f} if no such element is found.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:833
msgid ""
"@deffn {Scheme Procedure} take-while pred lst\n"
"@deffnx {Scheme Procedure} take-while! pred lst\n"
"Return the longest initial prefix of @var{lst} whose elements all\n"
"satisfy the predicate @var{pred}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:837
msgid ""
"@code{take-while!} is allowed, but not required to modify the input\n"
"list while producing the result.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:842
msgid ""
"@deffn {Scheme Procedure} drop-while pred lst\n"
"Drop the longest initial prefix of @var{lst} whose elements all\n"
"satisfy the predicate @var{pred}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:850
msgid ""
"@deffn {Scheme Procedure} span pred lst\n"
"@deffnx {Scheme Procedure} span! pred lst\n"
"@deffnx {Scheme Procedure} break pred lst\n"
"@deffnx {Scheme Procedure} break! pred lst\n"
"@code{span} splits the list @var{lst} into the longest initial prefix\n"
"whose elements all satisfy the predicate @var{pred}, and the remaining\n"
"tail.  @code{break} inverts the sense of the predicate."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:854
msgid ""
"@code{span!} and @code{break!} are allowed, but not required to modify\n"
"the structure of the input list @var{lst} in order to produce the\n"
"result."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:860
msgid ""
"Note that the name @code{break} conflicts with the @code{break}\n"
"binding established by @code{while} (@pxref{while do}).  Applications\n"
"wanting to use @code{break} from within a @code{while} loop will need\n"
"to make a new define under a different name.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:866
msgid ""
"@deffn {Scheme Procedure} any pred lst1 lst2 @dots{}\n"
"Test whether any set of elements from @var{lst1} @var{lst2} @dots{}\n"
"satisfies @var{pred}.  If so, the return value is the return value from\n"
"the successful @var{pred} call, or if not, the return value is\n"
"@code{#f}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:873
msgid ""
"If there are n list arguments, then @var{pred} must be a predicate\n"
"taking n arguments.  Each @var{pred} call is @code{(@var{pred}\n"
"@var{elem1} @var{elem2} @dots{} )} taking an element from each\n"
"@var{lst}.  The calls are made successively for the first, second, etc.\n"
"elements of the lists, stopping when @var{pred} returns non-@code{#f},\n"
"or when the end of the shortest list is reached."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:878
msgid ""
"The @var{pred} call on the last set of elements (i.e., when the end of\n"
"the shortest list has been reached), if that point is reached, is a\n"
"tail call.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:883
msgid ""
"@deffn {Scheme Procedure} every pred lst1 lst2 @dots{}\n"
"Test whether every set of elements from @var{lst1} @var{lst2} @dots{}\n"
"satisfies @var{pred}.  If so, the return value is the return from the\n"
"final @var{pred} call, or if not, the return value is @code{#f}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:890
msgid ""
"If there are n list arguments, then @var{pred} must be a predicate\n"
"taking n arguments.  Each @var{pred} call is @code{(@var{pred}\n"
"@var{elem1} @var{elem2 @dots{}})} taking an element from each\n"
"@var{lst}.  The calls are made successively for the first, second, etc.\n"
"elements of the lists, stopping if @var{pred} returns @code{#f}, or when\n"
"the end of any of the lists is reached."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:893
msgid ""
"The @var{pred} call on the last set of elements (i.e., when the end of\n"
"the shortest list has been reached) is a tail call."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:897
msgid ""
"If one of @var{lst1} @var{lst2} @dots{}is empty then no calls to\n"
"@var{pred} are made, and the return value is @code{#t}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:901
msgid ""
"@deffn {Scheme Procedure} list-index pred lst1 lst2 @dots{}\n"
"Return the index of the first set of elements, one from each of\n"
"@var{lst1} @var{lst2} @dots{}, which satisfies @var{pred}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:906
msgid ""
"@var{pred} is called as @code{(@var{elem1} @var{elem2 @dots{}})}.\n"
"Searching stops when the end of the shortest @var{lst} is reached.\n"
"The return index starts from 0 for the first set of elements.  If no\n"
"set of elements pass, then the return value is @code{#f}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:912
msgid ""
"@example\n"
"(list-index odd? '(2 4 6 9))      @result{} 3\n"
"(list-index = '(1 2 3) '(3 1 2))  @result{} #f\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:916
msgid ""
"@deffn {Scheme Procedure} member x lst [=]\n"
"Return the first sublist of @var{lst} whose @sc{car} is equal to\n"
"@var{x}.  If @var{x} does not appear in @var{lst}, return @code{#f}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:921
msgid ""
"Equality is determined by @code{equal?}, or by the equality predicate\n"
"@var{=} if given.  @var{=} is called @code{(= @var{x} elem)},\n"
"ie.@: with the given @var{x} first, so for example to find the first\n"
"element greater than 5,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:925
msgid ""
"@example\n"
"(member 5 '(3 5 1 7 2 9) <) @result{} (7 2 9)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:929
msgid ""
"This version of @code{member} extends the core @code{member}\n"
"(@pxref{List Searching}) by accepting an equality predicate.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:934
msgid ""
"@node SRFI-1 Deleting\n"
"@subsubsection Deleting\n"
"@cindex list delete"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:940
msgid ""
"@deffn {Scheme Procedure} delete x lst [=]\n"
"@deffnx {Scheme Procedure} delete! x lst [=]\n"
"Return a list containing the elements of @var{lst} but with those\n"
"equal to @var{x} deleted.  The returned elements will be in the same\n"
"order as they were in @var{lst}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:944
msgid ""
"Equality is determined by the @var{=} predicate, or @code{equal?} if\n"
"not given.  An equality call is made just once for each element, but\n"
"the order in which the calls are made on the elements is unspecified."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:948
msgid ""
"The equality calls are always @code{(= x elem)}, ie.@: the given @var{x}\n"
"is first.  This means for instance elements greater than 5 can be\n"
"deleted with @code{(delete 5 lst <)}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:952
msgid ""
"@code{delete} does not modify @var{lst}, but the return might share a\n"
"common tail with @var{lst}.  @code{delete!} may modify the structure\n"
"of @var{lst} to construct its return."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:958
msgid ""
"These functions extend the core @code{delete} and @code{delete!}\n"
"(@pxref{List Modification}) in accepting an equality predicate.  See\n"
"also @code{lset-difference} (@pxref{SRFI-1 Set Operations}) for\n"
"deleting multiple elements from a list.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:963
msgid ""
"@deffn {Scheme Procedure} delete-duplicates lst [=]\n"
"@deffnx {Scheme Procedure} delete-duplicates! lst [=]\n"
"Return a list containing the elements of @var{lst} but without\n"
"duplicates."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:968
msgid ""
"When elements are equal, only the first in @var{lst} is retained.\n"
"Equal elements can be anywhere in @var{lst}, they don't have to be\n"
"adjacent.  The returned list will have the retained elements in the\n"
"same order as they were in @var{lst}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:974
msgid ""
"Equality is determined by the @var{=} predicate, or @code{equal?} if\n"
"not given.  Calls @code{(= x y)} are made with element @var{x} being\n"
"before @var{y} in @var{lst}.  A call is made at most once for each\n"
"combination, but the sequence of the calls across the elements is\n"
"unspecified."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:978
msgid ""
"@code{delete-duplicates} does not modify @var{lst}, but the return\n"
"might share a common tail with @var{lst}.  @code{delete-duplicates!}\n"
"may modify the structure of @var{lst} to construct its return."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:983
msgid ""
"In the worst case, this is an @math{O(N^2)} algorithm because it must\n"
"check each element against all those preceding it.  For long lists it\n"
"is more efficient to sort and then compare only adjacent elements.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:989
msgid ""
"@node SRFI-1 Association Lists\n"
"@subsubsection Association Lists\n"
"@cindex association list\n"
"@cindex alist"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:991
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:991"
msgid "@c FIXME::martin: Review me!"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:995
msgid ""
"Association lists are described in detail in section @ref{Association\n"
"Lists}.  The present section only documents the additional procedures\n"
"for dealing with association lists defined by SRFI-1."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1000
msgid ""
"@deffn {Scheme Procedure} assoc key alist [=]\n"
"Return the pair from @var{alist} which matches @var{key}.  This\n"
"extends the core @code{assoc} (@pxref{Retrieving Alist Entries}) by\n"
"taking an optional @var{=} comparison procedure."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1005
msgid ""
"The default comparison is @code{equal?}.  If an @var{=} parameter is\n"
"given it's called @code{(@var{=} @var{key} @var{alistcar})}, i.e.@: the\n"
"given target @var{key} is the first argument, and a @code{car} from\n"
"@var{alist} is second."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1007
msgid "For example a case-insensitive string lookup,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1013
msgid ""
"@example\n"
"(assoc \"yy\" '((\"XX\" . 1) (\"YY\" . 2)) string-ci=?)\n"
"@result{} (\"YY\" . 2)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1017
msgid ""
"@deffn {Scheme Procedure} alist-cons key datum alist\n"
"Cons a new association @var{key} and @var{datum} onto @var{alist} and\n"
"return the result.  This is equivalent to"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1021
msgid ""
"@lisp\n"
"(cons (cons @var{key} @var{datum}) @var{alist})\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1025
msgid ""
"@code{acons} (@pxref{Adding or Setting Alist Entries}) in the Guile\n"
"core does the same thing.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1030
msgid ""
"@deffn {Scheme Procedure} alist-copy alist\n"
"Return a newly allocated copy of @var{alist}, that means that the\n"
"spine of the list as well as the pairs are copied.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1036
msgid ""
"@deffn {Scheme Procedure} alist-delete key alist [=]\n"
"@deffnx {Scheme Procedure} alist-delete! key alist [=]\n"
"Return a list containing the elements of @var{alist} but with those\n"
"elements whose keys are equal to @var{key} deleted.  The returned\n"
"elements will be in the same order as they were in @var{alist}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1043
msgid ""
"Equality is determined by the @var{=} predicate, or @code{equal?} if\n"
"not given.  The order in which elements are tested is unspecified, but\n"
"each equality call is made @code{(= key alistkey)}, i.e.@: the given\n"
"@var{key} parameter is first and the key from @var{alist} second.\n"
"This means for instance all associations with a key greater than 5 can\n"
"be removed with @code{(alist-delete 5 alist <)}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1048
msgid ""
"@code{alist-delete} does not modify @var{alist}, but the return might\n"
"share a common tail with @var{alist}.  @code{alist-delete!} may modify\n"
"the list structure of @var{alist} to construct its return.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1053
msgid ""
"@node SRFI-1 Set Operations\n"
"@subsubsection Set Operations on Lists\n"
"@cindex list set operation"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1056
msgid ""
"Lists can be used to represent sets of objects.  The procedures in\n"
"this section operate on such lists as sets."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1062
msgid ""
"Note that lists are not an efficient way to implement large sets.  The\n"
"procedures here typically take time @math{@var{m}@cross{}@var{n}} when\n"
"operating on @var{m} and @var{n} element lists.  Other data structures\n"
"like trees, bitsets (@pxref{Bit Vectors}) or hash tables (@pxref{Hash\n"
"Tables}) are faster."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1069
msgid ""
"All these procedures take an equality predicate as the first argument.\n"
"This predicate is used for testing the objects in the list sets for\n"
"sameness.  This predicate must be consistent with @code{eq?}\n"
"(@pxref{Equality}) in the sense that if two list elements are\n"
"@code{eq?} then they must also be equal under the predicate.  This\n"
"simply means a given object must be equal to itself."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1075
msgid ""
"@deffn {Scheme Procedure} lset<= = list @dots{}\n"
"Return @code{#t} if each list is a subset of the one following it.\n"
"I.e., @var{list1} is a subset of @var{list2}, @var{list2} is a subset of\n"
"@var{list3}, etc., for as many lists as given.  If only one list or no\n"
"lists are given, the return value is @code{#t}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1079
msgid ""
"A list @var{x} is a subset of @var{y} if each element of @var{x} is\n"
"equal to some element in @var{y}.  Elements are compared using the\n"
"given @var{=} procedure, called as @code{(@var{=} xelem yelem)}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1086
msgid ""
"@example\n"
"(lset<= eq?)                      @result{} #t\n"
"(lset<= eqv? '(1 2 3) '(1))       @result{} #f\n"
"(lset<= eqv? '(1 3 2) '(4 3 1 2)) @result{} #t\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1092
msgid ""
"@deffn {Scheme Procedure} lset= = list @dots{}\n"
"Return @code{#t} if all argument lists are set-equal.  @var{list1} is\n"
"compared to @var{list2}, @var{list2} to @var{list3}, etc., for as many\n"
"lists as given.  If only one list or no lists are given, the return\n"
"value is @code{#t}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1099
msgid ""
"Two lists @var{x} and @var{y} are set-equal if each element of @var{x}\n"
"is equal to some element of @var{y} and conversely each element of\n"
"@var{y} is equal to some element of @var{x}.  The order of the\n"
"elements in the lists doesn't matter.  Element equality is determined\n"
"with the given @var{=} procedure, called as @code{(@var{=} xelem\n"
"yelem)}, but exactly which calls are made is unspecified."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1106
msgid ""
"@example\n"
"(lset= eq?)                      @result{} #t\n"
"(lset= eqv? '(1 2 3) '(3 2 1))   @result{} #t\n"
"(lset= string-ci=? '(\"a\" \"A\" \"b\") '(\"B\" \"b\" \"a\")) @result{} #t\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1112
msgid ""
"@deffn {Scheme Procedure} lset-adjoin = list elem @dots{}\n"
"Add to @var{list} any of the given @var{elem}s not already in the list.\n"
"@var{elem}s are @code{cons}ed onto the start of @var{list} (so the\n"
"return value shares a common tail with @var{list}), but the order that\n"
"the @var{elem}s are added is unspecified."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1116
msgid ""
"The given @var{=} procedure is used for comparing elements, called as\n"
"@code{(@var{=} listelem elem)}, i.e., the second argument is one of\n"
"the given @var{elem} parameters."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1121
msgid ""
"@example\n"
"(lset-adjoin eqv? '(1 2 3) 4 1 5) @result{} (5 4 1 2 3)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1129
msgid ""
"@deffn {Scheme Procedure} lset-union = list @dots{}\n"
"@deffnx {Scheme Procedure} lset-union! = list @dots{}\n"
"Return the union of the argument list sets.  The result is built by\n"
"taking the union of @var{list1} and @var{list2}, then the union of\n"
"that with @var{list3}, etc., for as many lists as given.  For one list\n"
"argument that list itself is the result, for no list arguments the\n"
"result is the empty list."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1135
msgid ""
"The union of two lists @var{x} and @var{y} is formed as follows.  If\n"
"@var{x} is empty then the result is @var{y}.  Otherwise start with\n"
"@var{x} as the result and consider each @var{y} element (from first to\n"
"last).  A @var{y} element not equal to something already in the result\n"
"is @code{cons}ed onto the result."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1140
msgid ""
"The given @var{=} procedure is used for comparing elements, called as\n"
"@code{(@var{=} relem yelem)}.  The first argument is from the result\n"
"accumulated so far, and the second is from the list being union-ed in.\n"
"But exactly which calls are made is otherwise unspecified."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1144
msgid ""
"Notice that duplicate elements in @var{list1} (or the first non-empty\n"
"list) are preserved, but that repeated elements in subsequent lists\n"
"are only added once."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1150
msgid ""
"@example\n"
"(lset-union eqv?)                          @result{} ()\n"
"(lset-union eqv? '(1 2 3))                 @result{} (1 2 3)\n"
"(lset-union eqv? '(1 2 1 3) '(2 4 5) '(5)) @result{} (5 4 1 2 1 3)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1155
msgid ""
"@code{lset-union} doesn't change the given lists but the result may\n"
"share a tail with the first non-empty list.  @code{lset-union!} can\n"
"modify all of the given lists to form the result.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1161
msgid ""
"@deffn {Scheme Procedure} lset-intersection = list1 list2 @dots{}\n"
"@deffnx {Scheme Procedure} lset-intersection! = list1 list2 @dots{}\n"
"Return the intersection of @var{list1} with the other argument lists,\n"
"meaning those elements of @var{list1} which are also in all of\n"
"@var{list2} etc.  For one list argument, just that list is returned."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1167
msgid ""
"The test for an element of @var{list1} to be in the return is simply\n"
"that it's equal to some element in each of @var{list2} etc.  Notice\n"
"this means an element appearing twice in @var{list1} but only once in\n"
"each of @var{list2} etc will go into the return twice.  The return has\n"
"its elements in the same order as they were in @var{list1}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1172
msgid ""
"The given @var{=} procedure is used for comparing elements, called as\n"
"@code{(@var{=} elem1 elemN)}.  The first argument is from @var{list1}\n"
"and the second is from one of the subsequent lists.  But exactly which\n"
"calls are made and in what order is unspecified."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1178
msgid ""
"@example\n"
"(lset-intersection eqv? '(x y))                        @result{} (x y)\n"
"(lset-intersection eqv? '(1 2 3) '(4 3 2))             @result{} (2 3)\n"
"(lset-intersection eqv? '(1 1 2 2) '(1 2) '(2 1) '(2)) @result{} (2 2)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1183
msgid ""
"The return from @code{lset-intersection} may share a tail with\n"
"@var{list1}.  @code{lset-intersection!} may modify @var{list1} to form\n"
"its result.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1189
msgid ""
"@deffn {Scheme Procedure} lset-difference = list1 list2 @dots{}\n"
"@deffnx {Scheme Procedure} lset-difference! = list1 list2 @dots{}\n"
"Return @var{list1} with any elements in @var{list2}, @var{list3} etc\n"
"removed (ie.@: subtracted).  For one list argument, just that list is\n"
"returned."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1194
msgid ""
"The given @var{=} procedure is used for comparing elements, called as\n"
"@code{(@var{=} elem1 elemN)}.  The first argument is from @var{list1}\n"
"and the second from one of the subsequent lists.  But exactly which\n"
"calls are made and in what order is unspecified."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1200
msgid ""
"@example\n"
"(lset-difference eqv? '(x y))             @result{} (x y)\n"
"(lset-difference eqv? '(1 2 3) '(3 1))    @result{} (2)\n"
"(lset-difference eqv? '(1 2 3) '(3) '(2)) @result{} (1)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1205
msgid ""
"The return from @code{lset-difference} may share a tail with\n"
"@var{list1}.  @code{lset-difference!} may modify @var{list1} to form\n"
"its result.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1211
msgid ""
"@deffn {Scheme Procedure} lset-diff+intersection = list1 list2 @dots{}\n"
"@deffnx {Scheme Procedure} lset-diff+intersection! = list1 list2 @dots{}\n"
"Return two values (@pxref{Multiple Values}), the difference and\n"
"intersection of the argument lists as per @code{lset-difference} and\n"
"@code{lset-intersection} above."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1216
msgid ""
"For two list arguments this partitions @var{list1} into those elements\n"
"of @var{list1} which are in @var{list2} and not in @var{list2}.  (But\n"
"for more than two arguments there can be elements of @var{list1} which\n"
"are neither part of the difference nor the intersection.)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1221
msgid ""
"One of the return values from @code{lset-diff+intersection} may share\n"
"a tail with @var{list1}.  @code{lset-diff+intersection!} may modify\n"
"@var{list1} to form its results.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1228
msgid ""
"@deffn {Scheme Procedure} lset-xor = list @dots{}\n"
"@deffnx {Scheme Procedure} lset-xor! = list @dots{}\n"
"Return an XOR of the argument lists.  For two lists this means those\n"
"elements which are in exactly one of the lists.  For more than two\n"
"lists it means those elements which appear in an odd number of the\n"
"lists."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1237
msgid ""
"To be precise, the XOR of two lists @var{x} and @var{y} is formed by\n"
"taking those elements of @var{x} not equal to any element of @var{y},\n"
"plus those elements of @var{y} not equal to any element of @var{x}.\n"
"Equality is determined with the given @var{=} procedure, called as\n"
"@code{(@var{=} e1 e2)}.  One argument is from @var{x} and the other\n"
"from @var{y}, but which way around is unspecified.  Exactly which\n"
"calls are made is also unspecified, as is the order of the elements in\n"
"the result."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1242
msgid ""
"@example\n"
"(lset-xor eqv? '(x y))             @result{} (x y)\n"
"(lset-xor eqv? '(1 2 3) '(4 3 2))  @result{} (4 1)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1247
msgid ""
"The return from @code{lset-xor} may share a tail with one of the list\n"
"arguments.  @code{lset-xor!} may modify @var{list1} to form its\n"
"result.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1252
msgid ""
"@node SRFI-2\n"
"@subsection SRFI-2 - and-let*\n"
"@cindex SRFI-2"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1255
msgid ""
"@noindent\n"
"The following syntax can be obtained with"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1259
msgid ""
"@lisp\n"
"(use-modules (srfi srfi-2))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1261
msgid "or alternatively"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1265
msgid ""
"@lisp\n"
"(use-modules (ice-9 and-let-star))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1268
msgid ""
"@deffn {library syntax} and-let* (clause @dots{}) body @dots{}\n"
"A combination of @code{and} and @code{let*}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1274
msgid ""
"Each @var{clause} is evaluated in turn, and if @code{#f} is obtained\n"
"then evaluation stops and @code{#f} is returned.  If all are\n"
"non-@code{#f} then @var{body} is evaluated and the last form gives the\n"
"return value, or if @var{body} is empty then the result is @code{#t}.\n"
"Each @var{clause} should be one of the following,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1284
msgid ""
"@table @code\n"
"@item (symbol expr)\n"
"Evaluate @var{expr}, check for @code{#f}, and bind it to @var{symbol}.\n"
"Like @code{let*}, that binding is available to subsequent clauses.\n"
"@item (expr)\n"
"Evaluate @var{expr} and check for @code{#f}.\n"
"@item symbol\n"
"Get the value bound to @var{symbol} and check for @code{#f}.\n"
"@end table"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1288
msgid ""
"Notice that @code{(expr)} has an ``extra'' pair of parentheses, for\n"
"instance @code{((eq? x y))}.  One way to remember this is to imagine\n"
"the @code{symbol} in @code{(symbol expr)} is omitted."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1292
msgid ""
"@code{and-let*} is good for calculations where a @code{#f} value means\n"
"termination, but where a non-@code{#f} value is going to be needed in\n"
"subsequent expressions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1296
msgid ""
"The following illustrates this, it returns text between brackets\n"
"@samp{[...]} in a string, or @code{#f} if there are no such brackets\n"
"(ie.@: either @code{string-index} gives @code{#f})."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1303
msgid ""
"@example\n"
"(define (extract-brackets str)\n"
"  (and-let* ((start (string-index str #\\[))\n"
"             (end   (string-index str #\\] start)))\n"
"    (substring str (1+ start) end)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1308
msgid ""
"The following shows plain variables and expressions tested too.\n"
"@code{diagnostic-levels} is taken to be an alist associating a\n"
"diagnostic type with a level.  @code{str} is printed only if the type\n"
"is known and its level is high enough."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1316
msgid ""
"@example\n"
"(define (show-diagnostic type str)\n"
"  (and-let* (want-diagnostics\n"
"             (level (assq-ref diagnostic-levels type))\n"
"             ((>= level current-diagnostic-level)))\n"
"    (display str)))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1321
msgid ""
"The advantage of @code{and-let*} is that an extended sequence of\n"
"expressions and tests doesn't require lots of nesting as would arise\n"
"from separate @code{and} and @code{let*}, or from @code{cond} with\n"
"@code{=>}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1323
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:1323"
msgid "@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1328
msgid ""
"@node SRFI-4\n"
"@subsection SRFI-4 - Homogeneous numeric vector datatypes\n"
"@cindex SRFI-4"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1334
msgid ""
"SRFI-4 provides an interface to uniform numeric vectors: vectors whose "
"elements\n"
"are all of a single numeric type. Guile offers uniform numeric vectors for\n"
"signed and unsigned 8-bit, 16-bit, 32-bit, and 64-bit integers, two sizes "
"of\n"
"floating point values, and, as an extension to SRFI-4, complex floating-"
"point\n"
"numbers of these two sizes."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1337
msgid ""
"The standard SRFI-4 procedures and data types may be included via loading "
"the\n"
"appropriate module:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1341
msgid ""
"@example\n"
"(use-modules (srfi srfi-4))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1347
msgid ""
"This module is currently a part of the default Guile environment, but it is "
"a\n"
"good practice to explicitly import the module. In the future, using SRFI-4\n"
"procedures without importing the SRFI-4 module will cause a deprecation "
"message\n"
"to be printed. (Of course, one may call the C functions at any time. Would "
"that\n"
"C had modules!)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1354
msgid ""
"@menu\n"
"* SRFI-4 Overview::             The warp and weft of uniform numeric vectors."
"\n"
"* SRFI-4 API::                  Uniform vectors, from Scheme and from C.\n"
"* SRFI-4 and Bytevectors::      SRFI-4 vectors are backed by bytevectors.\n"
"* SRFI-4 Extensions::           Guile-specific extensions to the standard.\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1357
msgid ""
"@node SRFI-4 Overview\n"
"@subsubsection SRFI-4 - Overview"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1367
msgid ""
"Uniform numeric vectors can be useful since they consume less memory\n"
"than the non-uniform, general vectors.  Also, since the types they can\n"
"store correspond directly to C types, it is easier to work with them\n"
"efficiently on a low level.  Consider image processing as an example,\n"
"where you want to apply a filter to some image.  While you could store\n"
"the pixels of an image in a general vector and write a general\n"
"convolution function, things are much more efficient with uniform\n"
"vectors: the convolution function knows that all pixels are unsigned\n"
"8-bit values (say), and can use a very tight inner loop."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1372
msgid ""
"This is implemented in Scheme by having the compiler notice calls to the "
"SRFI-4\n"
"accessors, and inline them to appropriate compiled code. From C you have "
"access\n"
"to the raw array; functions for efficiently working with uniform numeric "
"vectors\n"
"from C are listed at the end of this section."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1375
msgid ""
"Uniform numeric vectors are the special case of one dimensional uniform\n"
"numeric arrays."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1380
msgid ""
"There are 12 standard kinds of uniform numeric vectors, and they all have "
"their\n"
"own complement of constructors, accessors, and so on. Procedures that "
"operate on\n"
"a specific kind of uniform numeric vector have a ``tag'' in their name,\n"
"indicating the element type."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1384
msgid ""
"@table @nicode\n"
"@item u8\n"
"unsigned 8-bit integers"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1387
msgid ""
"@item s8\n"
"signed 8-bit integers"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1390
msgid ""
"@item u16\n"
"unsigned 16-bit integers"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1393
msgid ""
"@item s16\n"
"signed 16-bit integers"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1396
msgid ""
"@item u32\n"
"unsigned 32-bit integers"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1399
msgid ""
"@item s32\n"
"signed 32-bit integers"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1402
msgid ""
"@item u64\n"
"unsigned 64-bit integers"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1405
msgid ""
"@item s64\n"
"signed 64-bit integers"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1408
msgid ""
"@item f32\n"
"the C type @code{float}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1411
msgid ""
"@item f64\n"
"the C type @code{double}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1413
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:1413"
msgid "@end table"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1416
msgid ""
"In addition, Guile supports uniform arrays of complex numbers, with the\n"
"nonstandard tags:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1418
msgid "@table @nicode"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1422
msgid ""
"@item c32\n"
"complex numbers in rectangular form with the real and imaginary part\n"
"being a @code{float}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1426
msgid ""
"@item c64\n"
"complex numbers in rectangular form with the real and imaginary part\n"
"being a @code{double}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1428
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:1428"
msgid "@end table"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1432
msgid ""
"The external representation (ie.@: read syntax) for these vectors is\n"
"similar to normal Scheme vectors, but with an additional tag from the\n"
"tables above indicating the vector's type.  For example,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1437
msgid ""
"@lisp\n"
"#u16(1 2 3)\n"
"#f64(3.1415 2.71)\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1443
msgid ""
"Note that the read syntax for floating-point here conflicts with\n"
"@code{#f} for false.  In Standard Scheme one can write @code{(1 #f3)}\n"
"for a three element list @code{(1 #f 3)}, but for Guile @code{(1 #f3)}\n"
"is invalid.  @code{(1 #f 3)} is almost certainly what one should write\n"
"anyway to make the intention clear, so this is rarely a problem."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1447
msgid ""
"@node SRFI-4 API\n"
"@subsubsection SRFI-4 - API"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1450
msgid ""
"Note that the @nicode{c32} and @nicode{c64} functions are only available "
"from\n"
"@nicode{(srfi srfi-4 gnu)}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1478
msgid ""
"@deffn {Scheme Procedure} u8vector? obj\n"
"@deffnx {Scheme Procedure} s8vector? obj\n"
"@deffnx {Scheme Procedure} u16vector? obj\n"
"@deffnx {Scheme Procedure} s16vector? obj\n"
"@deffnx {Scheme Procedure} u32vector? obj\n"
"@deffnx {Scheme Procedure} s32vector? obj\n"
"@deffnx {Scheme Procedure} u64vector? obj\n"
"@deffnx {Scheme Procedure} s64vector? obj\n"
"@deffnx {Scheme Procedure} f32vector? obj\n"
"@deffnx {Scheme Procedure} f64vector? obj\n"
"@deffnx {Scheme Procedure} c32vector? obj\n"
"@deffnx {Scheme Procedure} c64vector? obj\n"
"@deffnx {C Function} scm_u8vector_p (obj)\n"
"@deffnx {C Function} scm_s8vector_p (obj)\n"
"@deffnx {C Function} scm_u16vector_p (obj)\n"
"@deffnx {C Function} scm_s16vector_p (obj)\n"
"@deffnx {C Function} scm_u32vector_p (obj)\n"
"@deffnx {C Function} scm_s32vector_p (obj)\n"
"@deffnx {C Function} scm_u64vector_p (obj)\n"
"@deffnx {C Function} scm_s64vector_p (obj)\n"
"@deffnx {C Function} scm_f32vector_p (obj)\n"
"@deffnx {C Function} scm_f64vector_p (obj)\n"
"@deffnx {C Function} scm_c32vector_p (obj)\n"
"@deffnx {C Function} scm_c64vector_p (obj)\n"
"Return @code{#t} if @var{obj} is a homogeneous numeric vector of the\n"
"indicated type.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1508
msgid ""
"@deffn  {Scheme Procedure} make-u8vector n [value]\n"
"@deffnx {Scheme Procedure} make-s8vector n [value]\n"
"@deffnx {Scheme Procedure} make-u16vector n [value]\n"
"@deffnx {Scheme Procedure} make-s16vector n [value]\n"
"@deffnx {Scheme Procedure} make-u32vector n [value]\n"
"@deffnx {Scheme Procedure} make-s32vector n [value]\n"
"@deffnx {Scheme Procedure} make-u64vector n [value]\n"
"@deffnx {Scheme Procedure} make-s64vector n [value]\n"
"@deffnx {Scheme Procedure} make-f32vector n [value]\n"
"@deffnx {Scheme Procedure} make-f64vector n [value]\n"
"@deffnx {Scheme Procedure} make-c32vector n [value]\n"
"@deffnx {Scheme Procedure} make-c64vector n [value]\n"
"@deffnx {C Function} scm_make_u8vector (n, value)\n"
"@deffnx {C Function} scm_make_s8vector (n, value)\n"
"@deffnx {C Function} scm_make_u16vector (n, value)\n"
"@deffnx {C Function} scm_make_s16vector (n, value)\n"
"@deffnx {C Function} scm_make_u32vector (n, value)\n"
"@deffnx {C Function} scm_make_s32vector (n, value)\n"
"@deffnx {C Function} scm_make_u64vector (n, value)\n"
"@deffnx {C Function} scm_make_s64vector (n, value)\n"
"@deffnx {C Function} scm_make_f32vector (n, value)\n"
"@deffnx {C Function} scm_make_f64vector (n, value)\n"
"@deffnx {C Function} scm_make_c32vector (n, value)\n"
"@deffnx {C Function} scm_make_c64vector (n, value)\n"
"Return a newly allocated homogeneous numeric vector holding @var{n}\n"
"elements of the indicated type.  If @var{value} is given, the vector\n"
"is initialized with that value, otherwise the contents are\n"
"unspecified.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1537
msgid ""
"@deffn  {Scheme Procedure} u8vector value @dots{}\n"
"@deffnx {Scheme Procedure} s8vector value @dots{}\n"
"@deffnx {Scheme Procedure} u16vector value @dots{}\n"
"@deffnx {Scheme Procedure} s16vector value @dots{}\n"
"@deffnx {Scheme Procedure} u32vector value @dots{}\n"
"@deffnx {Scheme Procedure} s32vector value @dots{}\n"
"@deffnx {Scheme Procedure} u64vector value @dots{}\n"
"@deffnx {Scheme Procedure} s64vector value @dots{}\n"
"@deffnx {Scheme Procedure} f32vector value @dots{}\n"
"@deffnx {Scheme Procedure} f64vector value @dots{}\n"
"@deffnx {Scheme Procedure} c32vector value @dots{}\n"
"@deffnx {Scheme Procedure} c64vector value @dots{}\n"
"@deffnx {C Function} scm_u8vector (values)\n"
"@deffnx {C Function} scm_s8vector (values)\n"
"@deffnx {C Function} scm_u16vector (values)\n"
"@deffnx {C Function} scm_s16vector (values)\n"
"@deffnx {C Function} scm_u32vector (values)\n"
"@deffnx {C Function} scm_s32vector (values)\n"
"@deffnx {C Function} scm_u64vector (values)\n"
"@deffnx {C Function} scm_s64vector (values)\n"
"@deffnx {C Function} scm_f32vector (values)\n"
"@deffnx {C Function} scm_f64vector (values)\n"
"@deffnx {C Function} scm_c32vector (values)\n"
"@deffnx {C Function} scm_c64vector (values)\n"
"Return a newly allocated homogeneous numeric vector of the indicated\n"
"type, holding the given parameter @var{value}s.  The vector length is\n"
"the number of parameters given.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1564
msgid ""
"@deffn {Scheme Procedure} u8vector-length vec\n"
"@deffnx {Scheme Procedure} s8vector-length vec\n"
"@deffnx {Scheme Procedure} u16vector-length vec\n"
"@deffnx {Scheme Procedure} s16vector-length vec\n"
"@deffnx {Scheme Procedure} u32vector-length vec\n"
"@deffnx {Scheme Procedure} s32vector-length vec\n"
"@deffnx {Scheme Procedure} u64vector-length vec\n"
"@deffnx {Scheme Procedure} s64vector-length vec\n"
"@deffnx {Scheme Procedure} f32vector-length vec\n"
"@deffnx {Scheme Procedure} f64vector-length vec\n"
"@deffnx {Scheme Procedure} c32vector-length vec\n"
"@deffnx {Scheme Procedure} c64vector-length vec\n"
"@deffnx {C Function} scm_u8vector_length (vec)\n"
"@deffnx {C Function} scm_s8vector_length (vec)\n"
"@deffnx {C Function} scm_u16vector_length (vec)\n"
"@deffnx {C Function} scm_s16vector_length (vec)\n"
"@deffnx {C Function} scm_u32vector_length (vec)\n"
"@deffnx {C Function} scm_s32vector_length (vec)\n"
"@deffnx {C Function} scm_u64vector_length (vec)\n"
"@deffnx {C Function} scm_s64vector_length (vec)\n"
"@deffnx {C Function} scm_f32vector_length (vec)\n"
"@deffnx {C Function} scm_f64vector_length (vec)\n"
"@deffnx {C Function} scm_c32vector_length (vec)\n"
"@deffnx {C Function} scm_c64vector_length (vec)\n"
"Return the number of elements in @var{vec}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1592
msgid ""
"@deffn {Scheme Procedure} u8vector-ref vec i\n"
"@deffnx {Scheme Procedure} s8vector-ref vec i\n"
"@deffnx {Scheme Procedure} u16vector-ref vec i\n"
"@deffnx {Scheme Procedure} s16vector-ref vec i\n"
"@deffnx {Scheme Procedure} u32vector-ref vec i\n"
"@deffnx {Scheme Procedure} s32vector-ref vec i\n"
"@deffnx {Scheme Procedure} u64vector-ref vec i\n"
"@deffnx {Scheme Procedure} s64vector-ref vec i\n"
"@deffnx {Scheme Procedure} f32vector-ref vec i\n"
"@deffnx {Scheme Procedure} f64vector-ref vec i\n"
"@deffnx {Scheme Procedure} c32vector-ref vec i\n"
"@deffnx {Scheme Procedure} c64vector-ref vec i\n"
"@deffnx {C Function} scm_u8vector_ref (vec, i)\n"
"@deffnx {C Function} scm_s8vector_ref (vec, i)\n"
"@deffnx {C Function} scm_u16vector_ref (vec, i)\n"
"@deffnx {C Function} scm_s16vector_ref (vec, i)\n"
"@deffnx {C Function} scm_u32vector_ref (vec, i)\n"
"@deffnx {C Function} scm_s32vector_ref (vec, i)\n"
"@deffnx {C Function} scm_u64vector_ref (vec, i)\n"
"@deffnx {C Function} scm_s64vector_ref (vec, i)\n"
"@deffnx {C Function} scm_f32vector_ref (vec, i)\n"
"@deffnx {C Function} scm_f64vector_ref (vec, i)\n"
"@deffnx {C Function} scm_c32vector_ref (vec, i)\n"
"@deffnx {C Function} scm_c64vector_ref (vec, i)\n"
"Return the element at index @var{i} in @var{vec}.  The first element\n"
"in @var{vec} is index 0.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1621
msgid ""
"@deffn {Scheme Procedure} u8vector-set! vec i value\n"
"@deffnx {Scheme Procedure} s8vector-set! vec i value\n"
"@deffnx {Scheme Procedure} u16vector-set! vec i value\n"
"@deffnx {Scheme Procedure} s16vector-set! vec i value\n"
"@deffnx {Scheme Procedure} u32vector-set! vec i value\n"
"@deffnx {Scheme Procedure} s32vector-set! vec i value\n"
"@deffnx {Scheme Procedure} u64vector-set! vec i value\n"
"@deffnx {Scheme Procedure} s64vector-set! vec i value\n"
"@deffnx {Scheme Procedure} f32vector-set! vec i value\n"
"@deffnx {Scheme Procedure} f64vector-set! vec i value\n"
"@deffnx {Scheme Procedure} c32vector-set! vec i value\n"
"@deffnx {Scheme Procedure} c64vector-set! vec i value\n"
"@deffnx {C Function} scm_u8vector_set_x (vec, i, value)\n"
"@deffnx {C Function} scm_s8vector_set_x (vec, i, value)\n"
"@deffnx {C Function} scm_u16vector_set_x (vec, i, value)\n"
"@deffnx {C Function} scm_s16vector_set_x (vec, i, value)\n"
"@deffnx {C Function} scm_u32vector_set_x (vec, i, value)\n"
"@deffnx {C Function} scm_s32vector_set_x (vec, i, value)\n"
"@deffnx {C Function} scm_u64vector_set_x (vec, i, value)\n"
"@deffnx {C Function} scm_s64vector_set_x (vec, i, value)\n"
"@deffnx {C Function} scm_f32vector_set_x (vec, i, value)\n"
"@deffnx {C Function} scm_f64vector_set_x (vec, i, value)\n"
"@deffnx {C Function} scm_c32vector_set_x (vec, i, value)\n"
"@deffnx {C Function} scm_c64vector_set_x (vec, i, value)\n"
"Set the element at index @var{i} in @var{vec} to @var{value}.  The\n"
"first element in @var{vec} is index 0.  The return value is\n"
"unspecified.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1648
msgid ""
"@deffn {Scheme Procedure} u8vector->list vec\n"
"@deffnx {Scheme Procedure} s8vector->list vec\n"
"@deffnx {Scheme Procedure} u16vector->list vec\n"
"@deffnx {Scheme Procedure} s16vector->list vec\n"
"@deffnx {Scheme Procedure} u32vector->list vec\n"
"@deffnx {Scheme Procedure} s32vector->list vec\n"
"@deffnx {Scheme Procedure} u64vector->list vec\n"
"@deffnx {Scheme Procedure} s64vector->list vec\n"
"@deffnx {Scheme Procedure} f32vector->list vec\n"
"@deffnx {Scheme Procedure} f64vector->list vec\n"
"@deffnx {Scheme Procedure} c32vector->list vec\n"
"@deffnx {Scheme Procedure} c64vector->list vec\n"
"@deffnx {C Function} scm_u8vector_to_list (vec)\n"
"@deffnx {C Function} scm_s8vector_to_list (vec)\n"
"@deffnx {C Function} scm_u16vector_to_list (vec)\n"
"@deffnx {C Function} scm_s16vector_to_list (vec)\n"
"@deffnx {C Function} scm_u32vector_to_list (vec)\n"
"@deffnx {C Function} scm_s32vector_to_list (vec)\n"
"@deffnx {C Function} scm_u64vector_to_list (vec)\n"
"@deffnx {C Function} scm_s64vector_to_list (vec)\n"
"@deffnx {C Function} scm_f32vector_to_list (vec)\n"
"@deffnx {C Function} scm_f64vector_to_list (vec)\n"
"@deffnx {C Function} scm_c32vector_to_list (vec)\n"
"@deffnx {C Function} scm_c64vector_to_list (vec)\n"
"Return a newly allocated list holding all elements of @var{vec}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1676
msgid ""
"@deffn  {Scheme Procedure} list->u8vector lst\n"
"@deffnx {Scheme Procedure} list->s8vector lst\n"
"@deffnx {Scheme Procedure} list->u16vector lst\n"
"@deffnx {Scheme Procedure} list->s16vector lst\n"
"@deffnx {Scheme Procedure} list->u32vector lst\n"
"@deffnx {Scheme Procedure} list->s32vector lst\n"
"@deffnx {Scheme Procedure} list->u64vector lst\n"
"@deffnx {Scheme Procedure} list->s64vector lst\n"
"@deffnx {Scheme Procedure} list->f32vector lst\n"
"@deffnx {Scheme Procedure} list->f64vector lst\n"
"@deffnx {Scheme Procedure} list->c32vector lst\n"
"@deffnx {Scheme Procedure} list->c64vector lst\n"
"@deffnx {C Function} scm_list_to_u8vector (lst)\n"
"@deffnx {C Function} scm_list_to_s8vector (lst)\n"
"@deffnx {C Function} scm_list_to_u16vector (lst)\n"
"@deffnx {C Function} scm_list_to_s16vector (lst)\n"
"@deffnx {C Function} scm_list_to_u32vector (lst)\n"
"@deffnx {C Function} scm_list_to_s32vector (lst)\n"
"@deffnx {C Function} scm_list_to_u64vector (lst)\n"
"@deffnx {C Function} scm_list_to_s64vector (lst)\n"
"@deffnx {C Function} scm_list_to_f32vector (lst)\n"
"@deffnx {C Function} scm_list_to_f64vector (lst)\n"
"@deffnx {C Function} scm_list_to_c32vector (lst)\n"
"@deffnx {C Function} scm_list_to_c64vector (lst)\n"
"Return a newly allocated homogeneous numeric vector of the indicated type,\n"
"initialized with the elements of the list @var{lst}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1694
msgid ""
"@deftypefn  {C Function} SCM scm_take_u8vector (const scm_t_uint8 *data, "
"size_t len)\n"
"@deftypefnx {C Function} SCM scm_take_s8vector (const scm_t_int8 *data, "
"size_t len)\n"
"@deftypefnx {C Function} SCM scm_take_u16vector (const scm_t_uint16 *data, "
"size_t len)\n"
"@deftypefnx {C Function} SCM scm_take_s16vector (const scm_t_int16 *data, "
"size_t len)\n"
"@deftypefnx {C Function} SCM scm_take_u32vector (const scm_t_uint32 *data, "
"size_t len)\n"
"@deftypefnx {C Function} SCM scm_take_s32vector (const scm_t_int32 *data, "
"size_t len)\n"
"@deftypefnx {C Function} SCM scm_take_u64vector (const scm_t_uint64 *data, "
"size_t len)\n"
"@deftypefnx {C Function} SCM scm_take_s64vector (const scm_t_int64 *data, "
"size_t len)\n"
"@deftypefnx {C Function} SCM scm_take_f32vector (const float *data, size_t "
"len)\n"
"@deftypefnx {C Function} SCM scm_take_f64vector (const double *data, size_t "
"len)\n"
"@deftypefnx {C Function} SCM scm_take_c32vector (const float *data, size_t "
"len)\n"
"@deftypefnx {C Function} SCM scm_take_c64vector (const double *data, size_t "
"len)\n"
"Return a new uniform numeric vector of the indicated type and length\n"
"that uses the memory pointed to by @var{data} to store its elements.\n"
"This memory will eventually be freed with @code{free}.  The argument\n"
"@var{len} specifies the number of elements in @var{data}, not its size\n"
"in bytes."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1700
msgid ""
"The @code{c32} and @code{c64} variants take a pointer to a C array of\n"
"@code{float}s or @code{double}s.  The real parts of the complex numbers\n"
"are at even indices in that array, the corresponding imaginary parts are\n"
"at the following odd index.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1717
msgid ""
"@deftypefn {C Function} {const scm_t_uint8 *} scm_u8vector_elements (SCM "
"vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {const scm_t_int8 *} scm_s8vector_elements (SCM "
"vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {const scm_t_uint16 *} scm_u16vector_elements (SCM "
"vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {const scm_t_int16 *} scm_s16vector_elements (SCM "
"vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {const scm_t_uint32 *} scm_u32vector_elements (SCM "
"vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {const scm_t_int32 *} scm_s32vector_elements (SCM "
"vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {const scm_t_uint64 *} scm_u64vector_elements (SCM "
"vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {const scm_t_int64 *} scm_s64vector_elements (SCM "
"vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {const float *} scm_f32vector_elements (SCM vec, "
"scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {const double *} scm_f64vector_elements (SCM vec, "
"scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {const float *} scm_c32vector_elements (SCM vec, "
"scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {const double *} scm_c64vector_elements (SCM vec, "
"scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"Like @code{scm_vector_elements} (@pxref{Vector Accessing from C}), but\n"
"returns a pointer to the elements of a uniform numeric vector of the\n"
"indicated kind.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1734
msgid ""
"@deftypefn {C Function} {scm_t_uint8 *} scm_u8vector_writable_elements (SCM "
"vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {scm_t_int8 *} scm_s8vector_writable_elements (SCM "
"vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {scm_t_uint16 *} scm_u16vector_writable_elements ("
"SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {scm_t_int16 *} scm_s16vector_writable_elements ("
"SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {scm_t_uint32 *} scm_u32vector_writable_elements ("
"SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {scm_t_int32 *} scm_s32vector_writable_elements ("
"SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {scm_t_uint64 *} scm_u64vector_writable_elements ("
"SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {scm_t_int64 *} scm_s64vector_writable_elements ("
"SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {float *} scm_f32vector_writable_elements (SCM vec, "
"scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {double *} scm_f64vector_writable_elements (SCM "
"vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {float *} scm_c32vector_writable_elements (SCM vec, "
"scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"@deftypefnx {C Function} {double *} scm_c64vector_writable_elements (SCM "
"vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)\n"
"Like @code{scm_vector_writable_elements} (@pxref{Vector Accessing from\n"
"C}), but returns a pointer to the elements of a uniform numeric vector\n"
"of the indicated kind.\n"
"@end deftypefn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1737
msgid ""
"@node SRFI-4 and Bytevectors\n"
"@subsubsection SRFI-4 - Relation to bytevectors"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1744
msgid ""
"Guile implements SRFI-4 vectors using bytevectors (@pxref{Bytevectors}). "
"Often\n"
"when you have a numeric vector, you end up wanting to write its bytes "
"somewhere,\n"
"or have access to the underlying bytes, or read in bytes from somewhere else."
"\n"
"Bytevectors are very good at this sort of thing. But the SRFI-4 APIs are "
"nicer\n"
"to use when doing number-crunching, because they are addressed by element "
"and\n"
"not by byte."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1748
msgid ""
"So as a compromise, Guile allows all bytevector functions to operate on "
"numeric\n"
"vectors. They address the underlying bytes in the native endianness, as one\n"
"would expect."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1754
msgid ""
"Following the same reasoning, that it's just bytes underneath, Guile also "
"allows\n"
"uniform vectors of a given type to be accessed as if they were of any type. "
"One\n"
"can fill a @nicode{u32vector}, and access its elements with\n"
"@nicode{u8vector-ref}. One can use @nicode{f64vector-ref} on bytevectors. It'"
"s\n"
"all the same to Guile."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1757
msgid ""
"In this way, uniform numeric vectors may be written to and read from\n"
"input/output ports using the procedures that operate on bytevectors."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1759
msgid "@xref{Bytevectors}, for more information."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1763
msgid ""
"@node SRFI-4 Extensions\n"
"@subsubsection SRFI-4 - Guile extensions"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1767
msgid ""
"Guile defines some useful extensions to SRFI-4, which are not available in "
"the\n"
"default Guile environment. They may be imported by loading the extensions\n"
"module:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1771
msgid ""
"@example\n"
"(use-modules (srfi srfi-4 gnu))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1801
msgid ""
"@deffn  {Scheme Procedure} any->u8vector obj\n"
"@deffnx {Scheme Procedure} any->s8vector obj\n"
"@deffnx {Scheme Procedure} any->u16vector obj\n"
"@deffnx {Scheme Procedure} any->s16vector obj\n"
"@deffnx {Scheme Procedure} any->u32vector obj\n"
"@deffnx {Scheme Procedure} any->s32vector obj\n"
"@deffnx {Scheme Procedure} any->u64vector obj\n"
"@deffnx {Scheme Procedure} any->s64vector obj\n"
"@deffnx {Scheme Procedure} any->f32vector obj\n"
"@deffnx {Scheme Procedure} any->f64vector obj\n"
"@deffnx {Scheme Procedure} any->c32vector obj\n"
"@deffnx {Scheme Procedure} any->c64vector obj\n"
"@deffnx {C Function} scm_any_to_u8vector (obj)\n"
"@deffnx {C Function} scm_any_to_s8vector (obj)\n"
"@deffnx {C Function} scm_any_to_u16vector (obj)\n"
"@deffnx {C Function} scm_any_to_s16vector (obj)\n"
"@deffnx {C Function} scm_any_to_u32vector (obj)\n"
"@deffnx {C Function} scm_any_to_s32vector (obj)\n"
"@deffnx {C Function} scm_any_to_u64vector (obj)\n"
"@deffnx {C Function} scm_any_to_s64vector (obj)\n"
"@deffnx {C Function} scm_any_to_f32vector (obj)\n"
"@deffnx {C Function} scm_any_to_f64vector (obj)\n"
"@deffnx {C Function} scm_any_to_c32vector (obj)\n"
"@deffnx {C Function} scm_any_to_c64vector (obj)\n"
"Return a (maybe newly allocated) uniform numeric vector of the indicated\n"
"type, initialized with the elements of @var{obj}, which must be a list,\n"
"a vector, or a uniform vector.  When @var{obj} is already a suitable\n"
"uniform numeric vector, it is returned unchanged.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1806
msgid ""
"@node SRFI-6\n"
"@subsection SRFI-6 - Basic String Ports\n"
"@cindex SRFI-6"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1813
msgid ""
"SRFI-6 defines the procedures @code{open-input-string},\n"
"@code{open-output-string} and @code{get-output-string}.  These\n"
"procedures are included in the Guile core, so using this module does not\n"
"make any difference at the moment.  But it is possible that support for\n"
"SRFI-6 will be factored out of the core library in the future, so using\n"
"this module does not hurt, after all."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1817
msgid ""
"@node SRFI-8\n"
"@subsection SRFI-8 - receive\n"
"@cindex SRFI-8"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1820
msgid ""
"@code{receive} is a syntax for making the handling of multiple-value\n"
"procedures easier.  It is documented in @xref{Multiple Values}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1824
msgid ""
"@node SRFI-9\n"
"@subsection SRFI-9 - define-record-type"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1829
msgid ""
"This SRFI is a syntax for defining new record types and creating\n"
"predicate, constructor, and field getter and setter functions.  It is\n"
"documented in the ``Data Types'' section of the manual (@pxref{SRFI-9\n"
"Records})."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1834
msgid ""
"@node SRFI-10\n"
"@subsection SRFI-10 - Hash-Comma Reader Extension\n"
"@cindex SRFI-10"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1841
msgid ""
"@cindex hash-comma\n"
"@cindex #,()\n"
"This SRFI implements a reader extension @code{#,()} called hash-comma.\n"
"It allows the reader to give new kinds of objects, for use both in data\n"
"and as constants or literals in source code.  This feature is available\n"
"with"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1845
msgid ""
"@example\n"
"(use-modules (srfi srfi-10))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1848
msgid ""
"@noindent\n"
"The new read syntax is of the form"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1852
msgid ""
"@example\n"
"#,(@var{tag} @var{arg}@dots{})\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1856
msgid ""
"@noindent\n"
"where @var{tag} is a symbol and the @var{arg}s are objects taken as\n"
"parameters.  @var{tag}s are registered with the following procedure."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1863
msgid ""
"@deffn {Scheme Procedure} define-reader-ctor tag proc\n"
"Register @var{proc} as the constructor for a hash-comma read syntax\n"
"starting with symbol @var{tag}, i.e.@: @nicode{#,(@var{tag} arg@dots{})}.\n"
"@var{proc} is called with the given arguments @code{(@var{proc}\n"
"arg@dots{})} and the object it returns is the result of the read.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1866
msgid ""
"@noindent\n"
"For example, a syntax giving a list of @var{N} copies of an object."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1871
msgid ""
"@example\n"
"(define-reader-ctor 'repeat\n"
"  (lambda (obj reps)\n"
"    (make-list reps obj)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1875
msgid ""
"(display '#,(repeat 99 3))\n"
"@print{} (99 99 99)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1879
msgid ""
"Notice the quote @nicode{'} when the @nicode{#,( )} is used.  The\n"
"@code{repeat} handler returns a list and the program must quote to use\n"
"it literally, the same as any other list.  Ie."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1885
msgid ""
"@example\n"
"(display '#,(repeat 99 3))\n"
"@result{}\n"
"(display '(99 99 99))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1890
msgid ""
"When a handler returns an object which is self-evaluating, like a\n"
"number or a string, then there's no need for quoting, just as there's\n"
"no need when giving those directly as literals.  For example an\n"
"addition,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1897
msgid ""
"@example\n"
"(define-reader-ctor 'sum\n"
"  (lambda (x y)\n"
"    (+ x y)))\n"
"(display #,(sum 123 456)) @print{} 579\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1902
msgid ""
"Once @code{(srfi srfi-10)} has loaded, @nicode{#,()} is available\n"
"globally, there's no need to use @code{(srfi srfi-10)} in later\n"
"modules.  Similarly the tags registered are global and can be used\n"
"anywhere once registered."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1905
msgid ""
"We do not recommend @nicode{#,()} reader extensions, however, and for\n"
"three reasons."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1910
msgid ""
"First of all, this SRFI is not modular: the tag is matched by name, not\n"
"as an identifier within a scope.  Defining a reader extension in one\n"
"part of a program can thus affect unrelated parts of a program because\n"
"the tag is not scoped."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1914
msgid ""
"Secondly, reader extensions can be hard to manage from a time\n"
"perspective: when does the reader extension take effect?  @xref{Eval\n"
"When}, for more discussion."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1922
msgid ""
"Finally, reader extensions can easily produce objects that can't be\n"
"reified to an object file by the compiler.  For example if you define a\n"
"reader extension that makes a hash table (@pxref{Hash Tables}), then it\n"
"will work fine when run with the interpreter, and you think you have a\n"
"neat hack.  But then if you try to compile your program, after wrangling\n"
"with the @code{eval-when} concerns mentioned above, the compiler will\n"
"carp that it doesn't know how to serialize a hash table to disk."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1931
msgid ""
"In the specific case of hash tables, it would be possible for Guile to\n"
"know how to pack hash tables into compiled files, but this doesn't work\n"
"in general.  What if the object you produce is an instance of a record\n"
"type?  Guile would then have to serialize the record type to disk too,\n"
"and then what happens if the program independently loads the code that\n"
"defines the record type?  Does it define the same type or a different\n"
"type?  Guile's record types are nominal, not structural, so the answer\n"
"is not clear at all."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1938
msgid ""
"For all of these reasons we recommend macros over reader extensions.\n"
"Macros fulfill many of the same needs while preserving modular\n"
"composition, and their interaction with @code{eval-when} is well-known.\n"
"If you need brevity, instead use @code{read-hash-extend} and make your\n"
"reader extension expand to a macro invocation.  In that way we preserve\n"
"scoping as much as possible.  @xref{Reader Extensions}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1943
msgid ""
"@node SRFI-11\n"
"@subsection SRFI-11 - let-values\n"
"@cindex SRFI-11"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1950
msgid ""
"@findex let-values\n"
"@findex let*-values\n"
"This module implements the binding forms for multiple values\n"
"@code{let-values} and @code{let*-values}.  These forms are similar to\n"
"@code{let} and @code{let*} (@pxref{Local Bindings}), but they support\n"
"binding of the values returned by multiple-valued expressions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1953
msgid ""
"Write @code{(use-modules (srfi srfi-11))} to make the bindings\n"
"available."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1961
msgid ""
"@lisp\n"
"(let-values (((x y) (values 1 2))\n"
"             ((z f) (values 3 4)))\n"
"   (+ x y z f))\n"
"@result{}\n"
"10\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1967
msgid ""
"@code{let-values} performs all bindings simultaneously, which means that\n"
"no expression in the binding clauses may refer to variables bound in the\n"
"same clause list.  @code{let*-values}, on the other hand, performs the\n"
"bindings sequentially, just like @code{let*} does for single-valued\n"
"expressions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1972
msgid ""
"@node SRFI-13\n"
"@subsection SRFI-13 - String Library\n"
"@cindex SRFI-13"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1974
msgid "The SRFI-13 procedures are always available, @xref{Strings}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1978
msgid ""
"@node SRFI-14\n"
"@subsection SRFI-14 - Character-set Library\n"
"@cindex SRFI-14"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1981
msgid ""
"The SRFI-14 data type and procedures are always available,\n"
"@xref{Character Sets}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1987
msgid ""
"@node SRFI-16\n"
"@subsection SRFI-16 - case-lambda\n"
"@cindex SRFI-16\n"
"@cindex variable arity\n"
"@cindex arity, variable"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1991
msgid ""
"SRFI-16 defines a variable-arity @code{lambda} form,\n"
"@code{case-lambda}. This form is available in the default Guile\n"
"environment. @xref{Case-lambda}, for more information."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1995
msgid ""
"@node SRFI-17\n"
"@subsection SRFI-17 - Generalized set!\n"
"@cindex SRFI-17"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:1999
msgid ""
"This SRFI implements a generalized @code{set!}, allowing some\n"
"``referencing'' functions to be used as the target location of a\n"
"@code{set!}.  This feature is available from"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2003
msgid ""
"@example\n"
"(use-modules (srfi srfi-17))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2006
msgid ""
"@noindent\n"
"For example @code{vector-ref} is extended so that"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2010
msgid ""
"@example\n"
"(set! (vector-ref vec idx) new-value)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2013
msgid ""
"@noindent\n"
"is equivalent to"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2017
msgid ""
"@example\n"
"(vector-set! vec idx new-value)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2022
msgid ""
"The idea is that a @code{vector-ref} expression identifies a location,\n"
"which may be either fetched or stored.  The same form is used for the\n"
"location in both cases, encouraging visual clarity.  This is similar\n"
"to the idea of an ``lvalue'' in C."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2027
msgid ""
"The mechanism for this kind of @code{set!} is in the Guile core\n"
"(@pxref{Procedures with Setters}).  This module adds definitions of\n"
"the following functions as procedures with setters, allowing them to\n"
"be targets of a @code{set!},"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2037
msgid ""
"@quotation\n"
"@nicode{car}, @nicode{cdr}, @nicode{caar}, @nicode{cadr},\n"
"@nicode{cdar}, @nicode{cddr}, @nicode{caaar}, @nicode{caadr},\n"
"@nicode{cadar}, @nicode{caddr}, @nicode{cdaar}, @nicode{cdadr},\n"
"@nicode{cddar}, @nicode{cdddr}, @nicode{caaaar}, @nicode{caaadr},\n"
"@nicode{caadar}, @nicode{caaddr}, @nicode{cadaar}, @nicode{cadadr},\n"
"@nicode{caddar}, @nicode{cadddr}, @nicode{cdaaar}, @nicode{cdaadr},\n"
"@nicode{cdadar}, @nicode{cdaddr}, @nicode{cddaar}, @nicode{cddadr},\n"
"@nicode{cdddar}, @nicode{cddddr}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2040
msgid ""
"@nicode{string-ref}, @nicode{vector-ref}\n"
"@end quotation"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2046
msgid ""
"The SRFI specifies @code{setter} (@pxref{Procedures with Setters}) as\n"
"a procedure with setter, allowing the setter for a procedure to be\n"
"changed, eg.@: @code{(set! (setter foo) my-new-setter-handler)}.\n"
"Currently Guile does not implement this, a setter can only be\n"
"specified on creation (@code{getter-with-setter} below)."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2051
msgid ""
"@defun getter-with-setter\n"
"The same as the Guile core @code{make-procedure-with-setter}\n"
"(@pxref{Procedures with Setters}).\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2056
msgid ""
"@node SRFI-18\n"
"@subsection SRFI-18 - Multithreading support\n"
"@cindex SRFI-18"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2059
msgid ""
"This is an implementation of the SRFI-18 threading and synchronization\n"
"library.  The functions and variables described here are provided by"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2063
msgid ""
"@example\n"
"(use-modules (srfi srfi-18))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2070
msgid ""
"SRFI-18 defines facilities for threads, mutexes, condition variables,\n"
"time, and exception handling.  Because these facilities are at a higher\n"
"level than Guile's primitives, they are implemented as a layer on top of\n"
"what Guile provides.  In particular this means that a Guile mutex is not\n"
"a SRFI-18 mutex, and a Guile thread is not a SRFI-18 thread, and so on.\n"
"Guile provides a set of primitives and SRFI-18 is one of the systems built "
"in terms of those primitives."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2078
msgid ""
"@menu\n"
"* SRFI-18 Threads::             Executing code \n"
"* SRFI-18 Mutexes::             Mutual exclusion devices\n"
"* SRFI-18 Condition variables:: Synchronizing of groups of threads\n"
"* SRFI-18 Time::                Representation of times and durations\n"
"* SRFI-18 Exceptions::          Signalling and handling errors\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2081
msgid ""
"@node SRFI-18 Threads\n"
"@subsubsection SRFI-18 Threads"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2088
msgid ""
"Threads created by SRFI-18 differ in two ways from threads created by \n"
"Guile's built-in thread functions.  First, a thread created by SRFI-18\n"
"@code{make-thread} begins in a blocked state and will not start \n"
"execution until @code{thread-start!} is called on it.  Second, SRFI-18\n"
"threads are constructed with a top-level exception handler that \n"
"captures any exceptions that are thrown on thread exit."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2091
msgid ""
"SRFI-18 threads are disjoint from Guile's primitive threads.\n"
"@xref{Threads}, for more on Guile's primitive facility."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2097
msgid ""
"@defun current-thread\n"
"Returns the thread that called this function.  This is the same\n"
"procedure as the same-named built-in procedure @code{current-thread}\n"
"(@pxref{Threads}).\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2103
msgid ""
"@defun thread? obj\n"
"Returns @code{#t} if @var{obj} is a thread, @code{#f} otherwise.  This\n"
"is the same procedure as the same-named built-in procedure \n"
"@code{thread?} (@pxref{Threads}).\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2108
msgid ""
"@defun make-thread thunk [name]\n"
"Call @code{thunk} in a new thread and with a new dynamic state,\n"
"returning the new thread and optionally assigning it the object name\n"
"@var{name}, which may be any Scheme object."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2114
msgid ""
"Note that the name @code{make-thread} conflicts with the \n"
"@code{(ice-9 threads)} function @code{make-thread}.  Applications \n"
"wanting to use both of these functions will need to refer to them by \n"
"different names.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2119
msgid ""
"@defun thread-name thread\n"
"Returns the name assigned to @var{thread} at the time of its creation,\n"
"or @code{#f} if it was not given a name.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2126
msgid ""
"@defun thread-specific thread\n"
"@defunx thread-specific-set! thread obj\n"
"Get or set the ``object-specific'' property of @var{thread}.  In\n"
"Guile's implementation of SRFI-18, this value is stored as an object\n"
"property, and will be @code{#f} if not set.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2131
msgid ""
"@defun thread-start! thread\n"
"Unblocks @var{thread} and allows it to begin execution if it has not\n"
"done so already.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2138
msgid ""
"@defun thread-yield!\n"
"If one or more threads are waiting to execute, calling \n"
"@code{thread-yield!} forces an immediate context switch to one of them.\n"
"Otherwise, @code{thread-yield!} has no effect.  @code{thread-yield!} \n"
"behaves identically to the Guile built-in function @code{yield}.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2145
msgid ""
"@defun thread-sleep! timeout\n"
"The current thread waits until the point specified by the time object\n"
"@var{timeout} is reached (@pxref{SRFI-18 Time}).  This blocks the \n"
"thread only if @var{timeout} represents a point in the future.  it is \n"
"an error for @var{timeout} to be @code{#f}.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2155
msgid ""
"@defun thread-terminate! thread\n"
"Causes an abnormal termination of @var{thread}.  If @var{thread} is\n"
"not already terminated, all mutexes owned by @var{thread} become\n"
"unlocked/abandoned.  If @var{thread} is the current thread, \n"
"@code{thread-terminate!} does not return.  Otherwise \n"
"@code{thread-terminate!} returns an unspecified value; the termination\n"
"of @var{thread} will occur before @code{thread-terminate!} returns.  \n"
"Subsequent attempts to join on @var{thread} will cause a ``terminated \n"
"thread exception'' to be raised."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2163
msgid ""
"@code{thread-terminate!} is compatible with the thread cancellation\n"
"procedures in the core threads API (@pxref{Threads}) in that if a \n"
"cleanup handler has been installed for the target thread, it will be \n"
"called before the thread exits and its return value (or exception, if\n"
"any) will be stored for later retrieval via a call to \n"
"@code{thread-join!}.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2178
msgid ""
"@defun thread-join! thread [timeout [timeout-val]]\n"
"Wait for @var{thread} to terminate and return its exit value.  When a \n"
"time value @var{timeout} is given, it specifies a point in time where\n"
"the waiting should be aborted.  When the waiting is aborted, \n"
"@var{timeout-val} is returned if it is specified; otherwise, a\n"
"@code{join-timeout-exception} exception is raised \n"
"(@pxref{SRFI-18 Exceptions}).  Exceptions may also be raised if the \n"
"thread was terminated by a call to @code{thread-terminate!} \n"
"(@code{terminated-thread-exception} will be raised) or if the thread \n"
"exited by raising an exception that was handled by the top-level \n"
"exception handler (@code{uncaught-exception} will be raised; the \n"
"original exception can be retrieved using \n"
"@code{uncaught-exception-reason}).\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2182
msgid ""
"@node SRFI-18 Mutexes\n"
"@subsubsection SRFI-18 Mutexes"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2186
msgid ""
"SRFI-18 mutexes are disjoint from Guile's primitive mutexes.\n"
"@xref{Mutexes and Condition Variables}, for more on Guile's primitive\n"
"facility."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2192
msgid ""
"@defun make-mutex [name]\n"
"Returns a new mutex, optionally assigning it the object name @var{name},\n"
"which may be any Scheme object.  The returned mutex will be created with\n"
"the configuration described above.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2197
msgid ""
"@defun mutex-name mutex\n"
"Returns the name assigned to @var{mutex} at the time of its creation, or\n"
"@code{#f} if it was not given a name.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2202
msgid ""
"@defun mutex-specific mutex\n"
"Return the ``object-specific'' property of @var{mutex}, or @code{#f} if\n"
"none is set.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2206
msgid ""
"@defun mutex-specific-set! mutex obj\n"
"Set the ``object-specific'' property of @var{mutex}.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2223
msgid ""
"@defun mutex-state mutex\n"
"Returns information about the state of @var{mutex}.  Possible values \n"
"are:\n"
"@itemize @bullet\n"
"@item\n"
"thread @var{t}: the mutex is in the locked/owned state and thread\n"
"@var{t} is the owner of the mutex\n"
"@item \n"
"symbol @code{not-owned}: the mutex is in the locked/not-owned state\n"
"@item\n"
"symbol @code{abandoned}: the mutex is in the unlocked/abandoned state\n"
"@item\n"
"symbol @code{not-abandoned}: the mutex is in the \n"
"unlocked/not-abandoned state \n"
"@end itemize\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2229
msgid ""
"@defun mutex-lock! mutex [timeout [thread]]\n"
"Lock @var{mutex}, optionally specifying a time object @var{timeout}\n"
"after which to abort the lock attempt and a thread @var{thread} giving\n"
"a new owner for @var{mutex} different than the current thread.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2236
msgid ""
"@defun mutex-unlock! mutex [condition-variable [timeout]]\n"
"Unlock @var{mutex}, optionally specifying a condition variable\n"
"@var{condition-variable} on which to wait, either indefinitely or,\n"
"optionally, until the time object @var{timeout} has passed, to be\n"
"signalled.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2240
msgid ""
"@node SRFI-18 Condition variables\n"
"@subsubsection SRFI-18 Condition variables"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2244
msgid ""
"SRFI-18 does not specify a ``wait'' function for condition variables.\n"
"Waiting on a condition variable can be simulated using the SRFI-18\n"
"@code{mutex-unlock!} function described in the previous section."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2248
msgid ""
"SRFI-18 condition variables are disjoint from Guile's primitive\n"
"condition variables.  @xref{Mutexes and Condition Variables}, for more\n"
"on Guile's primitive facility."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2253
msgid ""
"@defun condition-variable? obj\n"
"Returns @code{#t} if @var{obj} is a condition variable, @code{#f}\n"
"otherwise.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2258
msgid ""
"@defun make-condition-variable [name]\n"
"Returns a new condition variable, optionally assigning it the object\n"
"name @var{name}, which may be any Scheme object.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2263
msgid ""
"@defun condition-variable-name condition-variable\n"
"Returns the name assigned to @var{condition-variable} at the time of its\n"
"creation, or @code{#f} if it was not given a name.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2268
msgid ""
"@defun condition-variable-specific condition-variable\n"
"Return the ``object-specific'' property of @var{condition-variable}, or\n"
"@code{#f} if none is set.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2272
msgid ""
"@defun condition-variable-specific-set! condition-variable obj\n"
"Set the ``object-specific'' property of @var{condition-variable}.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2279
msgid ""
"@defun condition-variable-signal! condition-variable\n"
"@defunx condition-variable-broadcast! condition-variable\n"
"Wake up one thread that is waiting for @var{condition-variable}, in\n"
"the case of @code{condition-variable-signal!}, or all threads waiting\n"
"for it, in the case of @code{condition-variable-broadcast!}.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2283
msgid ""
"@node SRFI-18 Time\n"
"@subsubsection SRFI-18 Time"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2289
msgid ""
"The SRFI-18 time functions manipulate time in two formats: a \n"
"``time object'' type that represents an absolute point in time in some \n"
"implementation-specific way; and the number of seconds since some \n"
"unspecified ``epoch''.  In Guile's implementation, the epoch is the\n"
"Unix epoch, 00:00:00 UTC, January 1, 1970."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2295
msgid ""
"@defun current-time\n"
"Return the current time as a time object.  This procedure replaces \n"
"the procedure of the same name in the core library, which returns the\n"
"current time in seconds since the epoch.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2299
msgid ""
"@defun time? obj\n"
"Returns @code{#t} if @var{obj} is a time object, @code{#f} otherwise.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2309
msgid ""
"@defun time->seconds time\n"
"@defunx seconds->time seconds\n"
"Convert between time objects and numerical values representing the\n"
"number of seconds since the epoch.  When converting from a time object \n"
"to seconds, the return value is the number of seconds between \n"
"@var{time} and the epoch.  When converting from seconds to a time \n"
"object, the return value is a time object that represents a time \n"
"@var{seconds} seconds after the epoch.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2313
msgid ""
"@node SRFI-18 Exceptions\n"
"@subsubsection SRFI-18 Exceptions"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2321
msgid ""
"SRFI-18 exceptions are identical to the exceptions provided by \n"
"Guile's implementation of SRFI-34.  The behavior of exception \n"
"handlers invoked to handle exceptions thrown from SRFI-18 functions,\n"
"however, differs from the conventional behavior of SRFI-34 in that\n"
"the continuation of the handler is the same as that of the call to\n"
"the function.  Handlers are called in a tail-recursive manner; the\n"
"exceptions do not ``bubble up''."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2325
msgid ""
"@defun current-exception-handler\n"
"Returns the current exception handler.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2333
msgid ""
"@defun with-exception-handler handler thunk\n"
"Installs @var{handler} as the current exception handler and calls the\n"
"procedure @var{thunk} with no arguments, returning its value as the \n"
"value of the exception.  @var{handler} must be a procedure that accepts\n"
"a single argument. The current exception handler at the time this \n"
"procedure is called will be restored after the call returns.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2338
msgid ""
"@defun raise obj\n"
"Raise @var{obj} as an exception.  This is the same procedure as the\n"
"same-named procedure defined in SRFI 34.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2344
msgid ""
"@defun join-timeout-exception? obj\n"
"Returns @code{#t} if @var{obj} is an exception raised as the result of \n"
"performing a timed join on a thread that does not exit within the\n"
"specified timeout, @code{#f} otherwise.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2350
msgid ""
"@defun abandoned-mutex-exception? obj\n"
"Returns @code{#t} if @var{obj} is an exception raised as the result of\n"
"attempting to lock a mutex that has been abandoned by its owner thread,\n"
"@code{#f} otherwise.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2356
msgid ""
"@defun terminated-thread-exception? obj\n"
"Returns @code{#t} if @var{obj} is an exception raised as the result of \n"
"joining on a thread that exited as the result of a call to\n"
"@code{thread-terminate!}.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2371
msgid ""
"@defun uncaught-exception? obj\n"
"@defunx uncaught-exception-reason exc\n"
"@code{uncaught-exception?} returns @code{#t} if @var{obj} is an \n"
"exception thrown as the result of joining a thread that exited by\n"
"raising an exception that was handled by the top-level exception\n"
"handler installed by @code{make-thread}.  When this occurs, the \n"
"original exception is preserved as part of the exception thrown by\n"
"@code{thread-join!} and can be accessed by calling \n"
"@code{uncaught-exception-reason} on that exception.  Note that\n"
"because this exception-preservation mechanism is a side-effect of\n"
"@code{make-thread}, joining on threads that exited as described above\n"
"but were created by other means will not raise this \n"
"@code{uncaught-exception} error.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2378
msgid ""
"@node SRFI-19\n"
"@subsection SRFI-19 - Time/Date Library\n"
"@cindex SRFI-19\n"
"@cindex time\n"
"@cindex date"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2381
msgid ""
"This is an implementation of the SRFI-19 time/date library.  The\n"
"functions and variables described here are provided by"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2385
msgid ""
"@example\n"
"(use-modules (srfi srfi-19))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2394
msgid ""
"@menu\n"
"* SRFI-19 Introduction::        \n"
"* SRFI-19 Time::                \n"
"* SRFI-19 Date::                \n"
"* SRFI-19 Time/Date conversions::  \n"
"* SRFI-19 Date to string::      \n"
"* SRFI-19 String to date::      \n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2397
msgid ""
"@node SRFI-19 Introduction\n"
"@subsubsection SRFI-19 Introduction"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2405
msgid ""
"@cindex universal time\n"
"@cindex atomic time\n"
"@cindex UTC\n"
"@cindex TAI\n"
"This module implements time and date representations and calculations,\n"
"in various time systems, including universal time (UTC) and atomic\n"
"time (TAI)."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2411
msgid ""
"For those not familiar with these time systems, TAI is based on a\n"
"fixed length second derived from oscillations of certain atoms.  UTC\n"
"differs from TAI by an integral number of seconds, which is increased\n"
"or decreased at announced times to keep UTC aligned to a mean solar\n"
"day (the orbit and rotation of the earth are not quite constant)."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2427
msgid ""
"@cindex leap second\n"
"So far, only increases in the TAI\n"
"@tex\n"
"$\\leftrightarrow$\n"
"@end tex\n"
"@ifnottex\n"
"<->\n"
"@end ifnottex\n"
"UTC difference have been needed.  Such an increase is a ``leap\n"
"second'', an extra second of TAI introduced at the end of a UTC day.\n"
"When working entirely within UTC this is never seen, every day simply\n"
"has 86400 seconds.  But when converting from TAI to a UTC date, an\n"
"extra 23:59:60 is present, where normally a day would end at 23:59:59.\n"
"Effectively the UTC second from 23:59:59 to 00:00:00 has taken two TAI\n"
"seconds."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2432
msgid ""
"@cindex system clock\n"
"In the current implementation, the system clock is assumed to be UTC,\n"
"and a table of leap seconds in the code converts to TAI.  See comments\n"
"in @file{srfi-19.scm} for how to update this table."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2441
msgid ""
"@cindex julian day\n"
"@cindex modified julian day\n"
"Also, for those not familiar with the terminology, a @dfn{Julian Day}\n"
"is a real number which is a count of days and fraction of a day, in\n"
"UTC, starting from -4713-01-01T12:00:00Z, ie.@: midday Monday 1 Jan\n"
"4713 B.C.  A @dfn{Modified Julian Day} is the same, but starting from\n"
"1858-11-17T00:00:00Z, ie.@: midnight 17 November 1858 UTC.  That time\n"
"is julian day 2400000.5."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2448
msgid ""
"@c  The SRFI-1 spec says -4714-11-24T12:00:00Z (November 24, -4714 at\n"
"@c  noon, UTC), but this is incorrect.  It looks like it might have\n"
"@c  arisen from the code incorrectly treating years a multiple of 100\n"
"@c  but not 400 prior to 1582 as non-leap years, where instead the Julian\n"
"@c  calendar should be used so all multiples of 4 before 1582 are leap\n"
"@c  years."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2453
msgid ""
"@node SRFI-19 Time\n"
"@subsubsection SRFI-19 Time\n"
"@cindex time"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2458
msgid ""
"A @dfn{time} object has type, seconds and nanoseconds fields\n"
"representing a point in time starting from some epoch.  This is an\n"
"arbitrary point in time, not just a time of day.  Although times are\n"
"represented in nanoseconds, the actual resolution may be lower."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2462
msgid ""
"The following variables hold the possible time types.  For instance\n"
"@code{(current-time time-process)} would give the current CPU process\n"
"time."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2467
msgid ""
"@defvar time-utc\n"
"Universal Coordinated Time (UTC).\n"
"@cindex UTC\n"
"@end defvar"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2472
msgid ""
"@defvar time-tai\n"
"International Atomic Time (TAI).\n"
"@cindex TAI\n"
"@end defvar"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2476
msgid ""
"@defvar time-monotonic\n"
"Monotonic time, meaning a monotonically increasing time starting from\n"
"an unspecified epoch."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2482
msgid ""
"Note that in the current implementation @code{time-monotonic} is the\n"
"same as @code{time-tai}, and unfortunately is therefore affected by\n"
"adjustments to the system clock.  Perhaps this will change in the\n"
"future.\n"
"@end defvar"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2486
msgid ""
"@defvar time-duration\n"
"A duration, meaning simply a difference between two times.\n"
"@end defvar"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2492
msgid ""
"@defvar time-process\n"
"CPU time spent in the current process, starting from when the process\n"
"began.\n"
"@cindex process time\n"
"@end defvar"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2497
msgid ""
"@defvar time-thread\n"
"CPU time spent in the current thread.  Not currently implemented.\n"
"@cindex thread time\n"
"@end defvar"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2502
msgid ""
"@sp 1\n"
"@defun time? obj\n"
"Return @code{#t} if @var{obj} is a time object, or @code{#f} if not.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2507
msgid ""
"@defun make-time type nanoseconds seconds\n"
"Create a time object with the given @var{type}, @var{seconds} and\n"
"@var{nanoseconds}.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2515
msgid ""
"@defun time-type time\n"
"@defunx time-nanosecond time\n"
"@defunx time-second time\n"
"@defunx set-time-type! time type\n"
"@defunx set-time-nanosecond! time nsec\n"
"@defunx set-time-second! time sec\n"
"Get or set the type, seconds or nanoseconds fields of a time object."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2519
msgid ""
"@code{set-time-type!} merely changes the field, it doesn't convert the\n"
"time value.  For conversions, see @ref{SRFI-19 Time/Date conversions}.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2523
msgid ""
"@defun copy-time time\n"
"Return a new time object, which is a copy of the given @var{time}.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2527
msgid ""
"@defun current-time [type]\n"
"Return the current time of the given @var{type}.  The default\n"
"@var{type} is @code{time-utc}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2534
msgid ""
"Note that the name @code{current-time} conflicts with the Guile core\n"
"@code{current-time} function (@pxref{Time}) as well as the SRFI-18\n"
"@code{current-time} function (@pxref{SRFI-18 Time}).  Applications \n"
"wanting to use more than one of these functions will need to refer to\n"
"them by different names.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2539
msgid ""
"@defun time-resolution [type]\n"
"Return the resolution, in nanoseconds, of the given time @var{type}.\n"
"The default @var{type} is @code{time-utc}.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2549
msgid ""
"@defun time<=? t1 t2\n"
"@defunx time<? t1 t2\n"
"@defunx time=? t1 t2\n"
"@defunx time>=? t1 t2\n"
"@defunx time>? t1 t2\n"
"Return @code{#t} or @code{#f} according to the respective relation\n"
"between time objects @var{t1} and @var{t2}.  @var{t1} and @var{t2}\n"
"must be the same time type.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2555
msgid ""
"@defun time-difference t1 t2\n"
"@defunx time-difference! t1 t2\n"
"Return a time object of type @code{time-duration} representing the\n"
"period between @var{t1} and @var{t2}.  @var{t1} and @var{t2} must be\n"
"the same time type."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2559
msgid ""
"@code{time-difference} returns a new time object,\n"
"@code{time-difference!} may modify @var{t1} to form its return.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2567
msgid ""
"@defun add-duration time duration\n"
"@defunx add-duration! time duration\n"
"@defunx subtract-duration time duration\n"
"@defunx subtract-duration! time duration\n"
"Return a time object which is @var{time} with the given @var{duration}\n"
"added or subtracted.  @var{duration} must be a time object of type\n"
"@code{time-duration}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2572
msgid ""
"@code{add-duration} and @code{subtract-duration} return a new time\n"
"object.  @code{add-duration!} and @code{subtract-duration!} may modify\n"
"the given @var{time} to form their return.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2577
msgid ""
"@node SRFI-19 Date\n"
"@subsubsection SRFI-19 Date\n"
"@cindex date"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2580
msgid ""
"A @dfn{date} object represents a date in the Gregorian calendar and a\n"
"time of day on that date in some timezone."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2584
msgid ""
"The fields are year, month, day, hour, minute, second, nanoseconds and\n"
"timezone.  A date object is immutable, its fields can be read but they\n"
"cannot be modified once the object is created."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2594
msgid ""
"Historically, the Gregorian calendar was only used from the latter part\n"
"of the year 1582 onwards, and not until even later in many countries.\n"
"Prior to that most countries used the Julian calendar.  SRFI-19 does\n"
"not deal with the Julian calendar at all, and so does not reflect this\n"
"historical calendar reform.  Instead it projects the Gregorian calendar\n"
"back proleptically as far as necessary.  When dealing with historical\n"
"data, especially prior to the British Empire's adoption of the Gregorian\n"
"calendar in 1752, one should be mindful of which calendar is used in\n"
"each context, and apply non-SRFI-19 facilities to convert where necessary."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2598
msgid ""
"@defun date? obj\n"
"Return @code{#t} if @var{obj} is a date object, or @code{#f} if not.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2607
msgid ""
"@defun make-date nsecs seconds minutes hours date month year zone-offset\n"
"Create a new date object.\n"
"@c\n"
"@c  FIXME: What can we say about the ranges of the values.  The\n"
"@c  current code looks it doesn't normalize, but expects then in their\n"
"@c  usual range already.\n"
"@c\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2611
msgid ""
"@defun date-nanosecond date\n"
"Nanoseconds, 0 to 999999999.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2616
msgid ""
"@defun date-second date\n"
"Seconds, 0 to 59, or 60 for a leap second.  60 is never seen when working\n"
"entirely within UTC, it's only when converting to or from TAI.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2620
msgid ""
"@defun date-minute date\n"
"Minutes, 0 to 59.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2624
msgid ""
"@defun date-hour date\n"
"Hour, 0 to 23.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2628
msgid ""
"@defun date-day date\n"
"Day of the month, 1 to 31 (or less, according to the month).\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2632
msgid ""
"@defun date-month date\n"
"Month, 1 to 12.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2637
msgid ""
"@defun date-year date\n"
"Year, eg.@: 2003.  Dates B.C.@: are negative, eg.@: @math{-46} is 46\n"
"B.C.  There is no year 0, year @math{-1} is followed by year 1.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2641
msgid ""
"@defun date-zone-offset date\n"
"Time zone, an integer number of seconds east of Greenwich.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2645
msgid ""
"@defun date-year-day date\n"
"Day of the year, starting from 1 for 1st January.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2649
msgid ""
"@defun date-week-day date\n"
"Day of the week, starting from 0 for Sunday.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2659
msgid ""
"@defun date-week-number date dstartw\n"
"Week of the year, ignoring a first partial week.  @var{dstartw} is the\n"
"day of the week which is taken to start a week, 0 for Sunday, 1 for\n"
"Monday, etc.\n"
"@c\n"
"@c  FIXME: The spec doesn't say whether numbering starts at 0 or 1.\n"
"@c  The code looks like it's 0, if that's the correct intention.\n"
"@c\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2670
msgid ""
"@c  The SRFI text doesn't actually give the default for tz-offset, but\n"
"@c  the reference implementation has the local timezone and the\n"
"@c  conversions functions all specify that, so it should be ok to\n"
"@c  document it here.\n"
"@c\n"
"@defun current-date [tz-offset]\n"
"Return a date object representing the current date/time, in UTC offset\n"
"by @var{tz-offset}.  @var{tz-offset} is seconds east of Greenwich and\n"
"defaults to the local timezone.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2675
msgid ""
"@defun current-julian-day\n"
"@cindex julian day\n"
"Return the current Julian Day.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2680
msgid ""
"@defun current-modified-julian-day\n"
"@cindex modified julian day\n"
"Return the current Modified Julian Day.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2686
msgid ""
"@node SRFI-19 Time/Date conversions\n"
"@subsubsection SRFI-19 Time/Date conversions\n"
"@cindex time conversion\n"
"@cindex date conversion"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2728
msgid ""
"@defun date->julian-day date\n"
"@defunx date->modified-julian-day date\n"
"@defunx date->time-monotonic date\n"
"@defunx date->time-tai date\n"
"@defunx date->time-utc date\n"
"@end defun\n"
"@defun julian-day->date jdn [tz-offset]\n"
"@defunx julian-day->time-monotonic jdn\n"
"@defunx julian-day->time-tai jdn\n"
"@defunx julian-day->time-utc jdn\n"
"@end defun\n"
"@defun modified-julian-day->date jdn [tz-offset]\n"
"@defunx modified-julian-day->time-monotonic jdn\n"
"@defunx modified-julian-day->time-tai jdn\n"
"@defunx modified-julian-day->time-utc jdn\n"
"@end defun\n"
"@defun time-monotonic->date time [tz-offset]\n"
"@defunx time-monotonic->time-tai time\n"
"@defunx time-monotonic->time-tai! time\n"
"@defunx time-monotonic->time-utc time\n"
"@defunx time-monotonic->time-utc! time\n"
"@end defun\n"
"@defun time-tai->date time [tz-offset]\n"
"@defunx time-tai->julian-day time\n"
"@defunx time-tai->modified-julian-day time\n"
"@defunx time-tai->time-monotonic time\n"
"@defunx time-tai->time-monotonic! time\n"
"@defunx time-tai->time-utc time\n"
"@defunx time-tai->time-utc! time\n"
"@end defun\n"
"@defun time-utc->date time [tz-offset]\n"
"@defunx time-utc->julian-day time\n"
"@defunx time-utc->modified-julian-day time\n"
"@defunx time-utc->time-monotonic time\n"
"@defunx time-utc->time-monotonic! time\n"
"@defunx time-utc->time-tai time\n"
"@defunx time-utc->time-tai! time\n"
"@sp 1\n"
"Convert between dates, times and days of the respective types.  For\n"
"instance @code{time-tai->time-utc} accepts a @var{time} object of type\n"
"@code{time-tai} and returns an object of type @code{time-utc}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2731
msgid ""
"The @code{!} variants may modify their @var{time} argument to form\n"
"their return.  The plain functions create a new object."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2735
msgid ""
"For conversions to dates, @var{tz-offset} is seconds east of\n"
"Greenwich.  The default is the local timezone, at the given time, as\n"
"provided by the system, using @code{localtime} (@pxref{Time})."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2747
msgid ""
"On 32-bit systems, @code{localtime} is limited to a 32-bit\n"
"@code{time_t}, so a default @var{tz-offset} is only available for\n"
"times between Dec 1901 and Jan 2038.  For prior dates an application\n"
"might like to use the value in 1902, though some locations have zone\n"
"changes prior to that.  For future dates an application might like to\n"
"assume today's rules extend indefinitely.  But for correct daylight\n"
"savings transitions it will be necessary to take an offset for the\n"
"same day and time but a year in range and which has the same starting\n"
"weekday and same leap/non-leap (to support rules like last Sunday in\n"
"October).\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2752
msgid ""
"@node SRFI-19 Date to string\n"
"@subsubsection SRFI-19 Date to string\n"
"@cindex date to string\n"
"@cindex string, from date"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2758
msgid ""
"@defun date->string date [format]\n"
"Convert a date to a string under the control of a format.\n"
"@var{format} should be a string containing @samp{~} escapes, which\n"
"will be expanded as per the following conversion table.  The default\n"
"@var{format} is @samp{~c}, a locale-dependent date and time."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2762
msgid ""
"Many of these conversion characters are the same as POSIX\n"
"@code{strftime} (@pxref{Time}), but there are some extras and some\n"
"variations."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2772
msgid ""
"@multitable {MMMM} {MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM}\n"
"@item @nicode{~~} @tab literal ~\n"
"@item @nicode{~a} @tab locale abbreviated weekday, eg.@: @samp{Sun}\n"
"@item @nicode{~A} @tab locale full weekday, eg.@: @samp{Sunday}\n"
"@item @nicode{~b} @tab locale abbreviated month, eg.@: @samp{Jan}\n"
"@item @nicode{~B} @tab locale full month, eg.@: @samp{January}\n"
"@item @nicode{~c} @tab locale date and time, eg.@: @*\n"
"@samp{Fri Jul 14 20:28:42-0400 2000}\n"
"@item @nicode{~d} @tab day of month, zero padded, @samp{01} to @samp{31}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2778
msgid ""
"@c  Spec says d/m/y, reference implementation says m/d/y.\n"
"@c  Apparently the reference code was the intention, but would like to\n"
"@c  see an errata published for the spec before contradicting it here.\n"
"@c\n"
"@c  @item @nicode{~D} @tab date @nicode{~d/~m/~y}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2806
msgid ""
"@item @nicode{~e} @tab day of month, blank padded, @samp{ 1} to @samp{31}\n"
"@item @nicode{~f} @tab seconds and fractional seconds,\n"
"with locale decimal point, eg.@: @samp{5.2}\n"
"@item @nicode{~h} @tab same as @nicode{~b}\n"
"@item @nicode{~H} @tab hour, 24-hour clock, zero padded, @samp{00} to "
"@samp{23}\n"
"@item @nicode{~I} @tab hour, 12-hour clock, zero padded, @samp{01} to "
"@samp{12}\n"
"@item @nicode{~j} @tab day of year, zero padded, @samp{001} to @samp{366}\n"
"@item @nicode{~k} @tab hour, 24-hour clock, blank padded, @samp{ 0} to "
"@samp{23}\n"
"@item @nicode{~l} @tab hour, 12-hour clock, blank padded, @samp{ 1} to "
"@samp{12}\n"
"@item @nicode{~m} @tab month, zero padded, @samp{01} to @samp{12}\n"
"@item @nicode{~M} @tab minute, zero padded, @samp{00} to @samp{59}\n"
"@item @nicode{~n} @tab newline\n"
"@item @nicode{~N} @tab nanosecond, zero padded, @samp{000000000} to "
"@samp{999999999}\n"
"@item @nicode{~p} @tab locale AM or PM\n"
"@item @nicode{~r} @tab time, 12 hour clock, @samp{~I:~M:~S ~p}\n"
"@item @nicode{~s} @tab number of full seconds since ``the epoch'' in UTC\n"
"@item @nicode{~S} @tab second, zero padded @samp{00} to @samp{60} @*\n"
"(usual limit is 59, 60 is a leap second)\n"
"@item @nicode{~t} @tab horizontal tab character\n"
"@item @nicode{~T} @tab time, 24 hour clock, @samp{~H:~M:~S}\n"
"@item @nicode{~U} @tab week of year, Sunday first day of week,\n"
"@samp{00} to @samp{52}\n"
"@item @nicode{~V} @tab week of year, Monday first day of week,\n"
"@samp{01} to @samp{53}\n"
"@item @nicode{~w} @tab day of week, 0 for Sunday, @samp{0} to @samp{6}\n"
"@item @nicode{~W} @tab week of year, Monday first day of week,\n"
"@samp{00} to @samp{52}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2816
msgid ""
"@c  The spec has ~x as an apparent duplicate of ~W, and ~X as a locale\n"
"@c  date.  The reference code has ~x as the locale date and ~X as a\n"
"@c  locale time.  The rule is apparently that the code should be\n"
"@c  believed, but would like to see an errata for the spec before\n"
"@c  contradicting it here.\n"
"@c\n"
"@c  @item @nicode{~x} @tab week of year, Monday as first day of week,\n"
"@c  @samp{00} to @samp{53}\n"
"@c  @item @nicode{~X} @tab locale date, eg.@: @samp{07/31/00}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2828
msgid ""
"@item @nicode{~y} @tab year, two digits, @samp{00} to @samp{99}\n"
"@item @nicode{~Y} @tab year, full, eg.@: @samp{2003}\n"
"@item @nicode{~z} @tab time zone, RFC-822 style\n"
"@item @nicode{~Z} @tab time zone symbol (not currently implemented)\n"
"@item @nicode{~1} @tab ISO-8601 date, @samp{~Y-~m-~d}\n"
"@item @nicode{~2} @tab ISO-8601 time+zone, @samp{~H:~M:~S~z}\n"
"@item @nicode{~3} @tab ISO-8601 time, @samp{~H:~M:~S}\n"
"@item @nicode{~4} @tab ISO-8601 date/time+zone, @samp{~Y-~m-~dT~H:~M:~S~z}\n"
"@item @nicode{~5} @tab ISO-8601 date/time, @samp{~Y-~m-~dT~H:~M:~S}\n"
"@end multitable\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2832
msgid ""
"Conversions @samp{~D}, @samp{~x} and @samp{~X} are not currently\n"
"described here, since the specification and reference implementation\n"
"differ."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2837
msgid ""
"Conversion is locale-dependent on systems that support it\n"
"(@pxref{Accessing Locale Information}).  @xref{Locales,\n"
"@code{setlocale}}, for information on how to change the current\n"
"locale."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2843
msgid ""
"@node SRFI-19 String to date\n"
"@subsubsection SRFI-19 String to date\n"
"@cindex string to date\n"
"@cindex date, from string"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2847
msgid ""
"@c  FIXME: Can we say what happens when an incomplete date is\n"
"@c  converted?  I.e. fields left as 0, or what?  The spec seems to be\n"
"@c  silent on this."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2851
msgid ""
"@defun string->date input template\n"
"Convert an @var{input} string to a date under the control of a\n"
"@var{template} string.  Return a newly created date object."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2858
msgid ""
"Literal characters in @var{template} must match characters in\n"
"@var{input} and @samp{~} escapes must match the input forms described\n"
"in the table below.  ``Skip to'' means characters up to one of the\n"
"given type are ignored, or ``no skip'' for no skipping.  ``Read'' is\n"
"what's then read, and ``Set'' is the field affected in the date\n"
"object."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2862
msgid ""
"For example @samp{~Y} skips input characters until a digit is reached,\n"
"at which point it expects a year and stores that to the year field of\n"
"the date."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2868
msgid ""
"@multitable {MMMM} {@nicode{char-alphabetic?}} {MMMMMMMMMMMMMMMMMMMMMMMMM} "
"{@nicode{date-zone-offset}}\n"
"@item\n"
"@tab Skip to\n"
"@tab Read\n"
"@tab Set"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2873
msgid ""
"@item @nicode{~~}\n"
"@tab no skip\n"
"@tab literal ~\n"
"@tab nothing"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2878
msgid ""
"@item @nicode{~a}\n"
"@tab @nicode{char-alphabetic?}\n"
"@tab locale abbreviated weekday name\n"
"@tab nothing"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2883
msgid ""
"@item @nicode{~A}\n"
"@tab @nicode{char-alphabetic?}\n"
"@tab locale full weekday name\n"
"@tab nothing"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2888
msgid ""
"@c  Note that the SRFI spec says that ~b and ~B don't set anything,\n"
"@c  but that looks like a mistake.  The reference implementation sets\n"
"@c  the month field, which seems sensible and is what we describe\n"
"@c  here."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2893
msgid ""
"@item @nicode{~b}\n"
"@tab @nicode{char-alphabetic?}\n"
"@tab locale abbreviated month name\n"
"@tab @nicode{date-month}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2898
msgid ""
"@item @nicode{~B}\n"
"@tab @nicode{char-alphabetic?}\n"
"@tab locale full month name\n"
"@tab @nicode{date-month}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2903
msgid ""
"@item @nicode{~d}\n"
"@tab @nicode{char-numeric?}\n"
"@tab day of month\n"
"@tab @nicode{date-day}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2908
msgid ""
"@item @nicode{~e}\n"
"@tab no skip\n"
"@tab day of month, blank padded\n"
"@tab @nicode{date-day}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2911
msgid ""
"@item @nicode{~h}\n"
"@tab same as @samp{~b}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2916
msgid ""
"@item @nicode{~H}\n"
"@tab @nicode{char-numeric?}\n"
"@tab hour\n"
"@tab @nicode{date-hour}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2921
msgid ""
"@item @nicode{~k}\n"
"@tab no skip\n"
"@tab hour, blank padded\n"
"@tab @nicode{date-hour}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2926
msgid ""
"@item @nicode{~m}\n"
"@tab @nicode{char-numeric?}\n"
"@tab month\n"
"@tab @nicode{date-month}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2931
msgid ""
"@item @nicode{~M}\n"
"@tab @nicode{char-numeric?}\n"
"@tab minute\n"
"@tab @nicode{date-minute}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2936
msgid ""
"@item @nicode{~S}\n"
"@tab @nicode{char-numeric?}\n"
"@tab second\n"
"@tab @nicode{date-second}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2941
msgid ""
"@item @nicode{~y}\n"
"@tab no skip\n"
"@tab 2-digit year\n"
"@tab @nicode{date-year} within 50 years"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2946
msgid ""
"@item @nicode{~Y}\n"
"@tab @nicode{char-numeric?}\n"
"@tab year\n"
"@tab @nicode{date-year}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2952
msgid ""
"@item @nicode{~z}\n"
"@tab no skip\n"
"@tab time zone\n"
"@tab date-zone-offset\n"
"@end multitable"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2956
msgid ""
"Notice that the weekday matching forms don't affect the date object\n"
"returned, instead the weekday will be derived from the day, month and\n"
"year."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2962
msgid ""
"Conversion is locale-dependent on systems that support it\n"
"(@pxref{Accessing Locale Information}).  @xref{Locales,\n"
"@code{setlocale}}, for information on how to change the current\n"
"locale.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2966
msgid ""
"@node SRFI-23\n"
"@subsection SRFI-23 - Error Reporting\n"
"@cindex SRFI-23"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2968
msgid "The SRFI-23 @code{error} procedure is always available."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2975
msgid ""
"@node SRFI-26\n"
"@subsection SRFI-26 - specializing parameters\n"
"@cindex SRFI-26\n"
"@cindex parameter specialize\n"
"@cindex argument specialize\n"
"@cindex specialize parameter"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2978
msgid ""
"This SRFI provides a syntax for conveniently specializing selected\n"
"parameters of a function.  It can be used with,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2982
msgid ""
"@example\n"
"(use-modules (srfi srfi-26))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2987
msgid ""
"@deffn {library syntax} cut slot1 slot2 @dots{}\n"
"@deffnx {library syntax} cute slot1 slot2 @dots{}\n"
"Return a new procedure which will make a call (@var{slot1} @var{slot2}\n"
"@dots{}) but with selected parameters specialized to given expressions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2991
msgid ""
"An example will illustrate the idea.  The following is a\n"
"specialization of @code{write}, sending output to\n"
"@code{my-output-port},"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:2997
msgid ""
"@example\n"
"(cut write <> my-output-port)\n"
"@result{}\n"
"(lambda (obj) (write obj my-output-port))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3002
msgid ""
"The special symbol @code{<>} indicates a slot to be filled by an\n"
"argument to the new procedure.  @code{my-output-port} on the other\n"
"hand is an expression to be evaluated and passed, ie.@: it specializes\n"
"the behaviour of @code{write}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3008
msgid ""
"@table @nicode\n"
"@item <>\n"
"A slot to be filled by an argument from the created procedure.\n"
"Arguments are assigned to @code{<>} slots in the order they appear in\n"
"the @code{cut} form, there's no way to re-arrange arguments."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3011
msgid ""
"The first argument to @code{cut} is usually a procedure (or expression\n"
"giving a procedure), but @code{<>} is allowed there too.  For example,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3017
msgid ""
"@example\n"
"(cut <> 1 2 3)\n"
"@result{}\n"
"(lambda (proc) (proc 1 2 3))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3021
msgid ""
"@item <...>\n"
"A slot to be filled by all remaining arguments from the new procedure.\n"
"This can only occur at the end of a @code{cut} form."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3024
msgid ""
"For example, a procedure taking a variable number of arguments like\n"
"@code{max} but in addition enforcing a lower bound,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3027
msgid ""
"@example\n"
"(define my-lower-bound 123)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3033
msgid ""
"(cut max my-lower-bound <...>)\n"
"@result{}\n"
"(lambda arglist (apply max my-lower-bound arglist))\n"
"@end example\n"
"@end table"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3039
msgid ""
"For @code{cut} the specializing expressions are evaluated each time\n"
"the new procedure is called.  For @code{cute} they're evaluated just\n"
"once, when the new procedure is created.  The name @code{cute} stands\n"
"for ``@code{cut} with evaluated arguments''.  In all cases the\n"
"evaluations take place in an unspecified order."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3042
msgid ""
"The following illustrates the difference between @code{cut} and\n"
"@code{cute},"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3047
msgid ""
"@example\n"
"(cut format <> \"the time is ~s\" (current-time))\n"
"@result{}\n"
"(lambda (port) (format port \"the time is ~s\" (current-time)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3053
msgid ""
"(cute format <> \"the time is ~s\" (current-time))\n"
"@result{}\n"
"(let ((val (current-time)))\n"
"  (lambda (port) (format port \"the time is ~s\" val))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3057
msgid ""
"(There's no provision for a mixture of @code{cut} and @code{cute}\n"
"where some expressions would be evaluated every time but others\n"
"evaluated only once.)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3063
msgid ""
"@code{cut} is really just a shorthand for the sort of @code{lambda}\n"
"forms shown in the above examples.  But notice @code{cut} avoids the\n"
"need to name unspecialized parameters, and is more compact.  Use in\n"
"functional programming style or just with @code{map}, @code{for-each}\n"
"or similar is typical."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3066
msgid ""
"@example\n"
"(map (cut * 2 <>) '(1 2 3 4))         "
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3070
msgid ""
"(for-each (cut write <> my-port) my-list)  \n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3074
msgid ""
"@node SRFI-27\n"
"@subsection SRFI-27 - Sources of Random Bits\n"
"@cindex SRFI-27"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3078
msgid ""
"This subsection is based on the\n"
"@uref{http://srfi.schemers.org/srfi-27/srfi-27.html, specification of\n"
"SRFI-27} written by Sebastian Egner."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3081
msgid ""
"@c The copyright notice and license text of the SRFI-27 specification is\n"
"@c reproduced below:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3083
msgid "@c Copyright (C) Sebastian Egner (2002). All Rights Reserved."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3091
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:3091"
msgid ""
"@c Permission is hereby granted, free of charge, to any person obtaining a\n"
"@c copy of this software and associated documentation files (the\n"
"@c \"Software\"), to deal in the Software without restriction, including\n"
"@c without limitation the rights to use, copy, modify, merge, publish,\n"
"@c distribute, sublicense, and/or sell copies of the Software, and to\n"
"@c permit persons to whom the Software is furnished to do so, subject to\n"
"@c the following conditions:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3094
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:3094"
msgid ""
"@c The above copyright notice and this permission notice shall be included\n"
"@c in all copies or substantial portions of the Software."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3102
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:3102"
msgid ""
"@c THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, "
"EXPRESS\n"
"@c OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
"@c MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n"
"@c NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n"
"@c LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n"
"@c OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n"
"@c WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3108
msgid ""
"This SRFI provides access to a (pseudo) random number generator; for\n"
"Guile's built-in random number facilities, which SRFI-27 is implemented\n"
"upon, @xref{Random}.  With SRFI-27, random numbers are obtained from a\n"
"@emph{random source}, which encapsulates a random number generation\n"
"algorithm and its state."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3114
msgid ""
"@menu\n"
"* SRFI-27 Default Random Source::    Obtaining random numbers\n"
"* SRFI-27 Random Sources::           Creating and manipulating random "
"sources\n"
"* SRFI-27 Random Number Generators:: Obtaining random number generators\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3118
msgid ""
"@node SRFI-27 Default Random Source\n"
"@subsubsection The Default Random Source\n"
"@cindex SRFI-27"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3124
msgid ""
"@defun random-integer n\n"
"Return a random number between zero (inclusive) and @var{n} (exclusive),\n"
"using the default random source.  The numbers returned have a uniform\n"
"distribution.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3129
msgid ""
"@defun random-real\n"
"Return a random number in (0,1), using the default random source.  The\n"
"numbers returned have a uniform distribution.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3139
msgid ""
"@defun default-random-source\n"
"A random source from which @code{random-integer} and @code{random-real}\n"
"have been derived using @code{random-source-make-integers} and\n"
"@code{random-source-make-reals} (@pxref{SRFI-27 Random Number Generators}\n"
"for those procedures).  Note that an assignment to\n"
"@code{default-random-source} does not change @code{random-integer} or\n"
"@code{random-real}; it is also strongly recommended not to assign a new\n"
"value.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3143
msgid ""
"@node SRFI-27 Random Sources\n"
"@subsubsection Random Sources\n"
"@cindex SRFI-27"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3149
msgid ""
"@defun make-random-source\n"
"Create a new random source.  The stream of random numbers obtained from\n"
"each random source created by this procedure will be identical, unless\n"
"its state is changed by one of the procedures below.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3154
msgid ""
"@defun random-source? object\n"
"Tests whether @var{object} is a random source.  Random sources are a\n"
"disjoint type.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3159
msgid ""
"@defun random-source-randomize! source\n"
"Attempt to set the state of the random source to a truly random value.\n"
"The current implementation uses a seed based on the current system time.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3169
msgid ""
"@defun random-source-pseudo-randomize! source i j\n"
"Changes the state of the random source s into the initial state of the\n"
"(@var{i}, @var{j})-th independent random source, where @var{i} and\n"
"@var{j} are non-negative integers.  This procedure provides a mechanism\n"
"to obtain a large number of independent random sources (usually all\n"
"derived from the same backbone generator), indexed by two integers. In\n"
"contrast to @code{random-source-randomize!}, this procedure is entirely\n"
"deterministic.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3172
msgid ""
"The state associated with a random state can be obtained an reinstated\n"
"with the following procedures:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3180
msgid ""
"@defun random-source-state-ref source\n"
"@defunx random-source-state-set! source state\n"
"Get and set the state of a random source.  No assumptions should be made\n"
"about the nature of the state object, besides it having an external\n"
"representation (i.e.@: it can be passed to @code{write} and subsequently\n"
"@code{read} back).\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3184
msgid ""
"@node SRFI-27 Random Number Generators\n"
"@subsubsection Obtaining random number generator procedures\n"
"@cindex SRFI-27"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3191
msgid ""
"@defun random-source-make-integers source\n"
"Obtains a procedure to generate random integers using the random source\n"
"@var{source}.  The returned procedure takes a single argument @var{n},\n"
"which must be a positive integer, and returns the next uniformly\n"
"distributed random integer from the interval @{0, ..., @var{n}-1@} by\n"
"advancing the state of @var{source}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3198
msgid ""
"If an application obtains and uses several generators for the same\n"
"random source @var{source}, a call to any of these generators advances\n"
"the state of @var{source}.  Hence, the generators do not produce the\n"
"same sequence of random integers each but rather share a state. This\n"
"also holds for all other types of generators derived from a fixed random\n"
"sources.  "
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3207
msgid ""
"While the SRFI text specifies that ``Implementations that support\n"
"concurrency make sure that the state of a generator is properly\n"
"advanced'', this is currently not the case in Guile's implementation of\n"
"SRFI-27, as it would cause a severe performance penalty.  So in\n"
"multi-threaded programs, you either must perform locking on random\n"
"sources shared between threads yourself, or use different random sources\n"
"for multiple threads.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3213
msgid ""
"@defun random-source-make-reals source\n"
"@defunx random-source-make-reals source unit\n"
"Obtains a procedure to generate random real numbers @math{0 < x < 1}\n"
"using the random source @var{source}.  The procedure rand is called\n"
"without arguments."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3227
msgid ""
"The optional parameter @var{unit} determines the type of numbers being\n"
"produced by the returned procedure and the quantization of the output.\n"
"@var{unit} must be a number such that @math{0 < @var{unit} < 1}.  The\n"
"numbers created by the returned procedure are of the same numerical type\n"
"as @var{unit} and the potential output values are spaced by at most\n"
"@var{unit}.  One can imagine rand to create numbers as @var{x} *\n"
"@var{unit} where @var{x} is a random integer in @{1, ...,\n"
"floor(1/unit)-1@}.  Note, however, that this need not be the way the\n"
"values are actually created and that the actual resolution of rand can\n"
"be much higher than unit. In case @var{unit} is absent it defaults to a\n"
"reasonably small value (related to the width of the mantissa of an\n"
"efficient number format).\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3231
msgid ""
"@node SRFI-28\n"
"@subsection SRFI-28 - Basic Format Strings\n"
"@cindex SRFI-28"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3235
msgid ""
"SRFI-28 provides a basic @code{format} procedure that provides only\n"
"the @code{~a}, @code{~s}, @code{~%}, and @code{~~} format specifiers.\n"
"You can import this procedure by using:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3239
msgid ""
"@lisp\n"
"(use-modules (srfi srfi-28))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3243
msgid ""
"@deffn {Scheme Procedure} format message arg @dots{}\n"
"Returns a formatted message, using @var{message} as the format string,\n"
"which can contain the following format specifiers:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3248
msgid ""
"@table @code\n"
"@item ~a\n"
"Insert the textual representation of the next @var{arg}, as if printed\n"
"by @code{display}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3252
msgid ""
"@item ~s\n"
"Insert the textual representation of the next @var{arg}, as if printed\n"
"by @code{write}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3255
msgid ""
"@item ~%\n"
"Insert a newline."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3259
msgid ""
"@item ~~\n"
"Insert a tilde.\n"
"@end table"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3263
msgid ""
"This procedure is the same as calling @code{simple-format}\n"
"(@pxref{Simple Output}) with @code{#f} as the destination.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3267
msgid ""
"@node SRFI-30\n"
"@subsection SRFI-30 - Nested Multi-line Comments\n"
"@cindex SRFI-30"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3270
msgid ""
"Starting from version 2.0, Guile's @code{read} supports SRFI-30/R6RS\n"
"nested multi-line comments by default, @ref{Block Comments}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3276
msgid ""
"@node SRFI-31\n"
"@subsection SRFI-31 - A special form `rec' for recursive evaluation\n"
"@cindex SRFI-31\n"
"@cindex recursive expression\n"
"@findex rec"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3280
msgid ""
"SRFI-31 defines a special form that can be used to create\n"
"self-referential expressions more conveniently.  The syntax is as\n"
"follows:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3287
msgid ""
"@example\n"
"@group\n"
"<rec expression> --> (rec <variable> <expression>)\n"
"<rec expression> --> (rec (<variable>+) <body>)\n"
"@end group\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3290
msgid ""
"The first syntax can be used to create self-referential expressions,\n"
"for example:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3294
msgid ""
"@lisp\n"
"  guile> (define tmp (rec ones (cons 1 (delay ones))))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3296
msgid "The second syntax can be used to create anonymous recursive functions:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3305
msgid ""
"@lisp\n"
"  guile> (define tmp (rec (display-n item n)\n"
"                       (if (positive? n)\n"
"                           (begin (display n) (display-n (- n 1))))))\n"
"  guile> (tmp 42 3)\n"
"  424242\n"
"  guile>\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3309
msgid ""
"@node SRFI-34\n"
"@subsection SRFI-34 - Exception handling for programs"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3315
msgid ""
"@cindex SRFI-34\n"
"Guile provides an implementation of\n"
"@uref{http://srfi.schemers.org/srfi-34/srfi-34.html, SRFI-34's exception\n"
"handling mechanisms} as an alternative to its own built-in mechanisms\n"
"(@pxref{Exceptions}).  It can be made available as follows:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3319
msgid ""
"@lisp\n"
"(use-modules (srfi srfi-34))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3321
msgid "@c FIXME: Document it."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3325
msgid ""
"@node SRFI-35\n"
"@subsection SRFI-35 - Conditions"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3329
msgid ""
"@cindex SRFI-35\n"
"@cindex conditions\n"
"@cindex exceptions"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3334
msgid ""
"@uref{http://srfi.schemers.org/srfi-35/srfi-35.html, SRFI-35} implements\n"
"@dfn{conditions}, a data structure akin to records designed to convey\n"
"information about exceptional conditions between parts of a program.  It\n"
"is normally used in conjunction with SRFI-34's @code{raise}:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3339
msgid ""
"@lisp\n"
"(raise (condition (&message\n"
"                    (message \"An error occurred\"))))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3344
msgid ""
"Users can define @dfn{condition types} containing arbitrary information.\n"
"Condition types may inherit from one another.  This allows the part of\n"
"the program that handles (or ``catches'') conditions to get accurate\n"
"information about the exceptional condition that arose."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3346
msgid "SRFI-35 conditions are made available using:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3350
msgid ""
"@lisp\n"
"(use-modules (srfi srfi-35))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3353
msgid ""
"The procedures available to manipulate condition types are the\n"
"following:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3360
msgid ""
"@deffn {Scheme Procedure} make-condition-type id parent field-names\n"
"Return a new condition type named @var{id}, inheriting from\n"
"@var{parent}, and with the fields whose names are listed in\n"
"@var{field-names}.  @var{field-names} must be a list of symbols and must\n"
"not contain names already used by @var{parent} or one of its supertypes.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3364
msgid ""
"@deffn {Scheme Procedure} condition-type? obj\n"
"Return true if @var{obj} is a condition type.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3366
msgid "Conditions can be created and accessed with the following procedures:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3371
msgid ""
"@deffn {Scheme Procedure} make-condition type . field+value\n"
"Return a new condition of type @var{type} with fields initialized as\n"
"specified by @var{field+value}, a sequence of field names (symbols) and\n"
"values as in the following example:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3376
msgid ""
"@lisp\n"
"(let ((&ct (make-condition-type 'foo &condition '(a b c))))\n"
"  (make-condition &ct 'a 1 'b 2 'c 3))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3379
msgid ""
"Note that all fields of @var{type} and its supertypes must be specified.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3386
msgid ""
"@deffn {Scheme Procedure} make-compound-condition condition1 condition2 "
"@dots{}\n"
"Return a new compound condition composed of @var{condition1}\n"
"@var{condition2} @enddots{}.  The returned condition has the type of\n"
"each condition of condition1 condition2 @dots{} (per\n"
"@code{condition-has-type?}).\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3390
msgid ""
"@deffn {Scheme Procedure} condition-has-type? c type\n"
"Return true if condition @var{c} has type @var{type}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3393
msgid ""
"@deffn {Scheme Procedure} condition-ref c field-name\n"
"Return the value of the field named @var{field-name} from condition @var{c}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3399
msgid ""
"If @var{c} is a compound condition and several underlying condition\n"
"types contain a field named @var{field-name}, then the value of the\n"
"first such field is returned, using the order in which conditions were\n"
"passed to @code{make-compound-condition}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3403
msgid ""
"@deffn {Scheme Procedure} extract-condition c type\n"
"Return a condition of condition type @var{type} with the field values\n"
"specified by @var{c}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3408
msgid ""
"If @var{c} is a compound condition, extract the field values from the\n"
"subcondition belonging to @var{type} that appeared first in the call to\n"
"@code{make-compound-condition} that created the condition.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3411
msgid ""
"Convenience macros are also available to create condition types and\n"
"conditions."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3420
msgid ""
"@deffn {library syntax} define-condition-type type supertype predicate field-"
"spec...\n"
"Define a new condition type named @var{type} that inherits from\n"
"@var{supertype}.  In addition, bind @var{predicate} to a type predicate\n"
"that returns true when passed a condition of type @var{type} or any of\n"
"its subtypes.  @var{field-spec} must have the form @code{(field\n"
"accessor)} where @var{field} is the name of field of @var{type} and\n"
"@var{accessor} is the name of a procedure to access field @var{field} in\n"
"conditions of type @var{type}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3423
msgid ""
"The example below defines condition type @code{&foo}, inheriting from\n"
"@code{&condition} with fields @code{a}, @code{b} and @code{c}:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3432
msgid ""
"@lisp\n"
"(define-condition-type &foo &condition\n"
"  foo-condition?\n"
"  (a  foo-a)\n"
"  (b  foo-b)\n"
"  (c  foo-c))\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3442
msgid ""
"@deffn {library syntax} condition type-field-binding1 type-field-binding2 "
"@dots{}\n"
"Return a new condition or compound condition, initialized according to\n"
"@var{type-field-binding1} @var{type-field-binding2} @enddots{}.  Each\n"
"@var{type-field-binding} must have the form @code{(type\n"
"field-specs...)}, where @var{type} is the name of a variable bound to a\n"
"condition type; each @var{field-spec} must have the form\n"
"@code{(field-name value)} where @var{field-name} is a symbol denoting\n"
"the field being initialized to @var{value}.  As for\n"
"@code{make-condition}, all fields must be specified."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3444
msgid "The following example returns a simple condition:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3448
msgid ""
"@lisp\n"
"(condition (&message (message \"An error occurred\")))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3450
msgid "The one below returns a compound condition:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3456
msgid ""
"@lisp\n"
"(condition (&message (message \"An error occurred\"))\n"
"           (&serious))\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3458
msgid "Finally, SRFI-35 defines a several standard condition types."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3463
msgid ""
"@defvar &condition\n"
"This condition type is the root of all condition types.  It has no\n"
"fields.\n"
"@end defvar"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3468
msgid ""
"@defvar &message\n"
"A condition type that carries a message describing the nature of the\n"
"condition to humans.\n"
"@end defvar"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3473
msgid ""
"@deffn {Scheme Procedure} message-condition? c\n"
"Return true if @var{c} is of type @code{&message} or one of its\n"
"subtypes.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3477
msgid ""
"@deffn {Scheme Procedure} condition-message c\n"
"Return the message associated with message condition @var{c}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3482
msgid ""
"@defvar &serious\n"
"This type describes conditions serious enough that they cannot safely be\n"
"ignored.  It has no fields.\n"
"@end defvar"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3487
msgid ""
"@deffn {Scheme Procedure} serious-condition? c\n"
"Return true if @var{c} is of type @code{&serious} or one of its\n"
"subtypes.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3493
msgid ""
"@defvar &error\n"
"This condition describes errors, typically caused by something that has\n"
"gone wrong in the interaction of the program with the external world or\n"
"the user.\n"
"@end defvar"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3497
msgid ""
"@deffn {Scheme Procedure} error? c\n"
"Return true if @var{c} is of type @code{&error} or one of its subtypes.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3501
msgid ""
"@node SRFI-37\n"
"@subsection SRFI-37 - args-fold\n"
"@cindex SRFI-37"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3508
msgid ""
"This is a processor for GNU @code{getopt_long}-style program\n"
"arguments.  It provides an alternative, less declarative interface\n"
"than @code{getopt-long} in @code{(ice-9 getopt-long)}\n"
"(@pxref{getopt-long,,The (ice-9 getopt-long) Module}).  Unlike\n"
"@code{getopt-long}, it supports repeated options and any number of\n"
"short and long names per option.  Access it with:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3512
msgid ""
"@lisp\n"
"(use-modules (srfi srfi-37))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3517
msgid ""
"@acronym{SRFI}-37 principally provides an @code{option} type and the\n"
"@code{args-fold} function.  To use the library, create a set of\n"
"options with @code{option} and use it as a specification for invoking\n"
"@code{args-fold}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3521
msgid ""
"Here is an example of a simple argument processor for the typical\n"
"@samp{--version} and @samp{--help} options, which returns a backwards\n"
"list of files given on the command line:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3538
msgid ""
"@lisp\n"
"(args-fold (cdr (program-arguments))\n"
"           (let ((display-and-exit-proc\n"
"                  (lambda (msg)\n"
"                    (lambda (opt name arg loads)\n"
"                      (display msg) (quit)))))\n"
"             (list (option '(#\\v \"version\") #f #f\n"
"                           (display-and-exit-proc \"Foo version 42.0\\n"
"\"))\n"
"                   (option '(#\\h \"help\") #f #f\n"
"                           (display-and-exit-proc\n"
"                            \"Usage: foo scheme-file ...\"))))\n"
"           (lambda (opt name arg loads)\n"
"             (error \"Unrecognized option `~A'\" name))\n"
"           (lambda (op loads) (cons op loads))\n"
"           '())\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3541
msgid ""
"@deffn {Scheme Procedure} option names required-arg? optional-arg? "
"processor\n"
"Return an object that specifies a single kind of program option."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3545
msgid ""
"@var{names} is a list of command-line option names, and should consist of\n"
"characters for traditional @code{getopt} short options and strings for\n"
"@code{getopt_long}-style long options."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3551
msgid ""
"@var{required-arg?} and @var{optional-arg?} are mutually exclusive;\n"
"one or both must be @code{#f}.  If @var{required-arg?}, the option\n"
"must be followed by an argument on the command line, such as\n"
"@samp{--opt=value} for long options, or an error will be signalled.\n"
"If @var{optional-arg?}, an argument will be taken if available."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3559
msgid ""
"@var{processor} is a procedure that takes at least 3 arguments, called\n"
"when @code{args-fold} encounters the option: the containing option\n"
"object, the name used on the command line, and the argument given for\n"
"the option (or @code{#f} if none).  The rest of the arguments are\n"
"@code{args-fold} ``seeds'', and the @var{processor} should return\n"
"seeds as well.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3567
msgid ""
"@deffn {Scheme Procedure} option-names opt\n"
"@deffnx {Scheme Procedure} option-required-arg? opt\n"
"@deffnx {Scheme Procedure} option-optional-arg? opt\n"
"@deffnx {Scheme Procedure} option-processor opt\n"
"Return the specified field of @var{opt}, an option object, as\n"
"described above for @code{option}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3575
msgid ""
"@deffn {Scheme Procedure} args-fold args options unrecognized-option-proc "
"operand-proc seed @dots{}\n"
"Process @var{args}, a list of program arguments such as that returned by\n"
"@code{(cdr (program-arguments))}, in order against @var{options}, a list\n"
"of option objects as described above.  All functions called take the\n"
"``seeds'', or the last multiple-values as multiple arguments, starting\n"
"with @var{seed} @dots{}, and must return the new seeds.  Return the\n"
"final seeds."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3578
msgid ""
"Call @code{unrecognized-option-proc}, which is like an option object's\n"
"processor, for any options not found in @var{options}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3583
msgid ""
"Call @code{operand-proc} with any items on the command line that are\n"
"not named options.  This includes arguments after @samp{--}.  It is\n"
"called with the argument in question, as well as the seeds.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3587
msgid ""
"@node SRFI-38\n"
"@subsection SRFI-38 - External Representation for Data With Shared "
"Structure\n"
"@cindex SRFI-38"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3591
msgid ""
"This subsection is based on\n"
"@uref{http://srfi.schemers.org/srfi-38/srfi-38.html, the specification\n"
"of SRFI-38} written by Ray Dillinger."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3593
msgid "@c Copyright (C) Ray Dillinger 2003. All Rights Reserved."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3601
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:3601"
msgid ""
"@c Permission is hereby granted, free of charge, to any person obtaining a\n"
"@c copy of this software and associated documentation files (the\n"
"@c \"Software\"), to deal in the Software without restriction, including\n"
"@c without limitation the rights to use, copy, modify, merge, publish,\n"
"@c distribute, sublicense, and/or sell copies of the Software, and to\n"
"@c permit persons to whom the Software is furnished to do so, subject to\n"
"@c the following conditions:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3604
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:3604"
msgid ""
"@c The above copyright notice and this permission notice shall be included\n"
"@c in all copies or substantial portions of the Software."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3612
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:3612"
msgid ""
"@c THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, "
"EXPRESS\n"
"@c OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
"@c MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n"
"@c NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n"
"@c LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n"
"@c OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n"
"@c WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3619
msgid ""
"This SRFI creates an alternative external representation for data\n"
"written and read using @code{write-with-shared-structure} and\n"
"@code{read-with-shared-structure}.  It is identical to the grammar for\n"
"external representation for data written and read with @code{write} and\n"
"@code{read} given in section 7 of R5RS, except that the single\n"
"production"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3623
msgid ""
"@example\n"
"<datum> --> <simple datum> | <compound datum> \n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3625
msgid "is replaced by the following five productions:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3633
msgid ""
"@example\n"
"<datum> --> <defining datum> | <nondefining datum> | <defined datum>\n"
"<defining datum> -->  #<indexnum>=<nondefining datum>\n"
"<defined datum> --> #<indexnum>#\n"
"<nondefining datum> --> <simple datum> | <compound datum> \n"
"<indexnum> --> <digit 10>+\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3637
msgid ""
"@deffn {Scheme procedure} write-with-shared-structure obj\n"
"@deffnx {Scheme procedure} write-with-shared-structure obj port\n"
"@deffnx {Scheme procedure} write-with-shared-structure obj port optarg"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3643
msgid ""
"Writes an external representation of @var{obj} to the given port.\n"
"Strings that appear in the written representation are enclosed in\n"
"doublequotes, and within those strings backslash and doublequote\n"
"characters are escaped by backslashes.  Character objects are written\n"
"using the @code{#\\} notation."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3654
msgid ""
"Objects which denote locations rather than values (cons cells, vectors,\n"
"and non-zero-length strings in R5RS scheme; also Guile's structs,\n"
"bytevectors and ports and hash-tables), if they appear at more than one\n"
"point in the data being written, are preceded by @samp{#@var{N}=} the\n"
"first time they are written and replaced by @samp{#@var{N}#} all\n"
"subsequent times they are written, where @var{N} is a natural number\n"
"used to identify that particular object.  If objects which denote\n"
"locations occur only once in the structure, then\n"
"@code{write-with-shared-structure} must produce the same external\n"
"representation for those objects as @code{write}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3657
msgid ""
"@code{write-with-shared-structure} terminates in finite time and\n"
"produces a finite representation when writing finite data."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3667
msgid ""
"@code{write-with-shared-structure} returns an unspecified value. The\n"
"@var{port} argument may be omitted, in which case it defaults to the\n"
"value returned by @code{(current-output-port)}.  The @var{optarg}\n"
"argument may also be omitted.  If present, its effects on the output and\n"
"return value are unspecified but @code{write-with-shared-structure} must\n"
"still write a representation that can be read by\n"
"@code{read-with-shared-structure}.  Some implementations may wish to use\n"
"@var{optarg} to specify formatting conventions, numeric radixes, or\n"
"return values.  Guile's implementation ignores @var{optarg}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3669
msgid "For example, the code"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3675
msgid ""
"@lisp\n"
"(begin (define a (cons 'val1 'val2))\n"
"       (set-cdr! a a)\n"
"       (write-with-shared-structure a))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3678
msgid ""
"should produce the output @code{#1=(val1 . #1#)}.  This shows a cons\n"
"cell whose @code{cdr} contains itself."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3680
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:3680"
msgid "@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3683
msgid ""
"@deffn {Scheme procedure} read-with-shared-structure\n"
"@deffnx {Scheme procedure} read-with-shared-structure port"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3692
msgid ""
"@code{read-with-shared-structure} converts the external representations\n"
"of Scheme objects produced by @code{write-with-shared-structure} into\n"
"Scheme objects.  That is, it is a parser for the nonterminal\n"
"@samp{<datum>} in the augmented external representation grammar defined\n"
"above.  @code{read-with-shared-structure} returns the next object\n"
"parsable from the given input port, updating @var{port} to point to the\n"
"first character past the end of the external representation of the\n"
"object."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3701
msgid ""
"If an end-of-file is encountered in the input before any characters are\n"
"found that can begin an object, then an end-of-file object is returned.\n"
"The port remains open, and further attempts to read it (by\n"
"@code{read-with-shared-structure} or @code{read} will also return an\n"
"end-of-file object.  If an end of file is encountered after the\n"
"beginning of an object's external representation, but the external\n"
"representation is incomplete and therefore not parsable, an error is\n"
"signalled."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3705
msgid ""
"The @var{port} argument may be omitted, in which case it defaults to the\n"
"value returned by @code{(current-input-port)}.  It is an error to read\n"
"from a closed port."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3707
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:3707"
msgid "@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3711
msgid ""
"@node SRFI-39\n"
"@subsection SRFI-39 - Parameters\n"
"@cindex SRFI-39"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3715
msgid ""
"This SRFI adds support for dynamically-scoped parameters.  SRFI 39 is\n"
"implemented in the Guile core; there's no module needed to get SRFI-39\n"
"itself.  Parameters are documented in @ref{Parameters}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3719
msgid ""
"This module does export one extra function: @code{with-parameters*}.\n"
"This is a Guile-specific addition to the SRFI, similar to the core\n"
"@code{with-fluids*} (@pxref{Fluids and Dynamic States})."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3727
msgid ""
"@defun with-parameters* param-list value-list thunk\n"
"Establish a new dynamic scope, as per @code{parameterize} above,\n"
"taking parameters from @var{param-list} and corresponding values from\n"
"@var{value-list}.  A call @code{(@var{thunk})} is made in the new\n"
"scope and the result from that @var{thunk} is the return from\n"
"@code{with-parameters*}.\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3731
msgid ""
"@node SRFI-41\n"
"@subsection SRFI-41 - Streams\n"
"@cindex SRFI-41"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3735
msgid ""
"This subsection is based on the\n"
"@uref{http://srfi.schemers.org/srfi-41/srfi-41.html, specification of\n"
"SRFI-41} by Philip L.@: Bewig."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3738
msgid ""
"@c The copyright notice and license text of the SRFI-41 specification is\n"
"@c reproduced below:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3740
msgid "@c Copyright (C) Philip L. Bewig (2007). All Rights Reserved."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3748
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:3748"
msgid ""
"@c Permission is hereby granted, free of charge, to any person obtaining a\n"
"@c copy of this software and associated documentation files (the\n"
"@c \"Software\"), to deal in the Software without restriction, including\n"
"@c without limitation the rights to use, copy, modify, merge, publish,\n"
"@c distribute, sublicense, and/or sell copies of the Software, and to\n"
"@c permit persons to whom the Software is furnished to do so, subject to\n"
"@c the following conditions:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3751
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:3751"
msgid ""
"@c The above copyright notice and this permission notice shall be included\n"
"@c in all copies or substantial portions of the Software."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3759
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:3759"
msgid ""
"@c THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, "
"EXPRESS\n"
"@c OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
"@c MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n"
"@c NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n"
"@c LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n"
"@c OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n"
"@c WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3767
msgid ""
"@noindent\n"
"This SRFI implements streams, sometimes called lazy lists, a sequential\n"
"data structure containing elements computed only on demand.  A stream is\n"
"either null or is a pair with a stream in its cdr.  Since elements of a\n"
"stream are computed only when accessed, streams can be infinite.  Once\n"
"computed, the value of a stream element is cached in case it is needed\n"
"again.  SRFI-41 can be made available with:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3771
msgid ""
"@example\n"
"(use-modules (srfi srfi-41))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3777
msgid ""
"@menu\n"
"* SRFI-41 Stream Fundamentals::\n"
"* SRFI-41 Stream Primitives::\n"
"* SRFI-41 Stream Library::\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3780
msgid ""
"@node SRFI-41 Stream Fundamentals\n"
"@subsubsection SRFI-41 Stream Fundamentals"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3788
msgid ""
"SRFI-41 Streams are based on two mutually-recursive abstract data types:\n"
"An object of the @code{stream} abstract data type is a promise that,\n"
"when forced, is either @code{stream-null} or is an object of type\n"
"@code{stream-pair}.  An object of the @code{stream-pair} abstract data\n"
"type contains a @code{stream-car} and a @code{stream-cdr}, which must be\n"
"a @code{stream}.  The essential feature of streams is the systematic\n"
"suspensions of the recursive promises between the two data types."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3796
msgid ""
"The object stored in the @code{stream-car} of a @code{stream-pair} is a\n"
"promise that is forced the first time the @code{stream-car} is accessed;\n"
"its value is cached in case it is needed again.  The object may have any\n"
"type, and different stream elements may have different types.  If the\n"
"@code{stream-car} is never accessed, the object stored there is never\n"
"evaluated.  Likewise, the @code{stream-cdr} is a promise to return a\n"
"stream, and is only forced on demand."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3799
msgid ""
"@node SRFI-41 Stream Primitives\n"
"@subsubsection SRFI-41 Stream Primitives"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3805
msgid ""
"This library provides eight operators: constructors for\n"
"@code{stream-null} and @code{stream-pair}s, type predicates for streams\n"
"and the two kinds of streams, accessors for both fields of a\n"
"@code{stream-pair}, and a lambda that creates procedures that return\n"
"streams."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3811
msgid ""
"@defvr {Scheme Variable} stream-null\n"
"A promise that, when forced, is a single object, distinguishable from\n"
"all other objects, that represents the null stream.  @code{stream-null}\n"
"is immutable and unique.\n"
"@end defvr"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3818
msgid ""
"@deffn {Scheme Syntax} stream-cons object-expr stream-expr\n"
"Creates a newly-allocated stream containing a promise that, when forced,\n"
"is a @code{stream-pair} with @var{object-expr} in its @code{stream-car}\n"
"and @var{stream-expr} in its @code{stream-cdr}.  Neither\n"
"@var{object-expr} nor @var{stream-expr} is evaluated when\n"
"@code{stream-cons} is called."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3824
msgid ""
"Once created, a @code{stream-pair} is immutable; there is no\n"
"@code{stream-set-car!}  or @code{stream-set-cdr!} that modifies an\n"
"existing stream-pair.  There is no dotted-pair or improper stream as\n"
"with lists.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3832
msgid ""
"@deffn {Scheme Procedure} stream? object\n"
"Returns true if @var{object} is a stream, otherwise returns false.  If\n"
"@var{object} is a stream, its promise will not be forced.  If\n"
"@code{(stream? obj)} returns true, then one of @code{(stream-null? obj)}\n"
"or @code{(stream-pair? obj)} will return true and the other will return\n"
"false.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3837
msgid ""
"@deffn {Scheme Procedure} stream-null? object\n"
"Returns true if @var{object} is the distinguished null stream, otherwise\n"
"returns false.  If @var{object} is a stream, its promise will be forced.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3843
msgid ""
"@deffn {Scheme Procedure} stream-pair? object\n"
"Returns true if @var{object} is a @code{stream-pair} constructed by\n"
"@code{stream-cons}, otherwise returns false.  If @var{object} is a\n"
"stream, its promise will be forced.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3851
msgid ""
"@deffn {Scheme Procedure} stream-car stream\n"
"Returns the object stored in the @code{stream-car} of @var{stream}.  An\n"
"error is signalled if the argument is not a @code{stream-pair}.  This\n"
"causes the @var{object-expr} passed to @code{stream-cons} to be\n"
"evaluated if it had not yet been; the value is cached in case it is\n"
"needed again.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3856
msgid ""
"@deffn {Scheme Procedure} stream-cdr stream\n"
"Returns the stream stored in the @code{stream-cdr} of @var{stream}.  An\n"
"error is signalled if the argument is not a @code{stream-pair}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3869
msgid ""
"@deffn {Scheme Syntax} stream-lambda formals body @dots{}\n"
"Creates a procedure that returns a promise to evaluate the @var{body} of\n"
"the procedure.  The last @var{body} expression to be evaluated must\n"
"yield a stream.  As with normal @code{lambda}, @var{formals} may be a\n"
"single variable name, in which case all the formal arguments are\n"
"collected into a single list, or a list of variable names, which may be\n"
"null if there are no arguments, proper if there are an exact number of\n"
"arguments, or dotted if a fixed number of arguments is to be followed by\n"
"zero or more arguments collected into a list.  @var{Body} must contain\n"
"at least one expression, and may contain internal definitions preceding\n"
"any expressions to be evaluated.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3876
msgid ""
"@example\n"
"(define strm123\n"
"  (stream-cons 1\n"
"    (stream-cons 2\n"
"      (stream-cons 3\n"
"        stream-null))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3879
msgid ""
"(stream-car strm123) @result{} 1\n"
"(stream-car (stream-cdr strm123) @result{} 2"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3883
msgid ""
"(stream-pair?\n"
"  (stream-cdr\n"
"    (stream-cons (/ 1 0) stream-null))) @result{} #f"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3885
msgid "(stream? (list 1 2 3)) @result{} #f"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3889
msgid ""
"(define iter\n"
"  (stream-lambda (f x)\n"
"    (stream-cons x (iter f (f x)))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3891
msgid "(define nats (iter (lambda (x) (+ x 1)) 0))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3893
msgid "(stream-car (stream-cdr nats)) @result{} 1"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3900
msgid ""
"(define stream-add\n"
"  (stream-lambda (s1 s2)\n"
"    (stream-cons\n"
"      (+ (stream-car s1) (stream-car s2))\n"
"      (stream-add (stream-cdr s1)\n"
"                  (stream-cdr s2)))))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3902
msgid "(define evens (stream-add nats nats))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3907
msgid ""
"(stream-car evens) @result{} 0\n"
"(stream-car (stream-cdr evens)) @result{} 2\n"
"(stream-car (stream-cdr (stream-cdr evens))) @result{} 4\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3910
msgid ""
"@node SRFI-41 Stream Library\n"
"@subsubsection SRFI-41 Stream Library"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3919
msgid ""
"@deffn {Scheme Syntax} define-stream (name args @dots{}) body @dots{}\n"
"Creates a procedure that returns a stream, and may appear anywhere a\n"
"normal @code{define} may appear, including as an internal definition.\n"
"It may contain internal definitions of its own.  The defined procedure\n"
"takes arguments in the same way as @code{stream-lambda}.\n"
"@code{define-stream} is syntactic sugar on @code{stream-lambda}; see\n"
"also @code{stream-let}, which is also a sugaring of\n"
"@code{stream-lambda}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3922
msgid ""
"A simple version of @code{stream-map} that takes only a single input\n"
"stream calls itself recursively:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3932
msgid ""
"@example\n"
"(define-stream (stream-map proc strm)\n"
"  (if (stream-null? strm)\n"
"      stream-null\n"
"      (stream-cons\n"
"        (proc (stream-car strm))\n"
"        (stream-map proc (stream-cdr strm))))))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3937
msgid ""
"@deffn {Scheme Procedure} list->stream list\n"
"Returns a newly-allocated stream containing the elements from\n"
"@var{list}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3943
msgid ""
"@deffn {Scheme Procedure} port->stream [port]\n"
"Returns a newly-allocated stream containing in its elements the\n"
"characters on the port.  If @var{port} is not given it defaults to the\n"
"current input port.  The returned stream has finite length and is\n"
"terminated by @code{stream-null}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3945
msgid "It looks like one use of @code{port->stream} would be this:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3951
msgid ""
"@example\n"
"(define s ;wrong!\n"
"  (with-input-from-file filename\n"
"    (lambda () (port->stream))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3955
msgid ""
"But that fails, because @code{with-input-from-file} is eager, and closes\n"
"the input port prematurely, before the first character is read.  To read\n"
"a file into a stream, say:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3967
msgid ""
"@example\n"
"(define-stream (file->stream filename)\n"
"  (let ((p (open-input-file filename)))\n"
"    (stream-let loop ((c (read-char p)))\n"
"      (if (eof-object? c)\n"
"          (begin (close-input-port p)\n"
"                 stream-null)\n"
"          (stream-cons c\n"
"            (loop (read-char p)))))))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3973
msgid ""
"@deffn {Scheme Syntax} stream object-expr @dots{}\n"
"Creates a newly-allocated stream containing in its elements the objects,\n"
"in order.  The @var{object-expr}s are evaluated when they are accessed,\n"
"not when the stream is created.  If no objects are given, as in\n"
"(stream), the null stream is returned.  See also @code{list->stream}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3976
msgid ""
"@example\n"
"(define strm123 (stream 1 2 3))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3981
msgid ""
"; (/ 1 0) not evaluated when stream is created\n"
"(define s (stream 1 (/ 1 0) -1))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3988
msgid ""
"@deffn {Scheme Procedure} stream->list [n] stream\n"
"Returns a newly-allocated list containing in its elements the first\n"
"@var{n} items in @var{stream}.  If @var{stream} has less than @var{n}\n"
"items, all the items in the stream will be included in the returned\n"
"list.  If @var{n} is not given it defaults to infinity, which means that\n"
"unless @var{stream} is finite @code{stream->list} will never return."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:3996
msgid ""
"@example\n"
"(stream->list 10\n"
"  (stream-map (lambda (x) (* x x))\n"
"    (stream-from 0)))\n"
"  @result{} (0 1 4 9 16 25 36 49 64 81)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4004
msgid ""
"@deffn {Scheme Procedure} stream-append stream @dots{}\n"
"Returns a newly-allocated stream containing in its elements those\n"
"elements contained in its input @var{stream}s, in order of input.  If\n"
"any of the input streams is infinite, no elements of any of the\n"
"succeeding input streams will appear in the output stream.  See also\n"
"@code{stream-concat}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4012
msgid ""
"@deffn {Scheme Procedure} stream-concat stream\n"
"Takes a @var{stream} consisting of one or more streams and returns a\n"
"newly-allocated stream containing all the elements of the input streams.\n"
"If any of the streams in the input @var{stream} is infinite, any\n"
"remaining streams in the input stream will never appear in the output\n"
"stream.  See also @code{stream-append}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4016
msgid ""
"@deffn {Scheme Procedure} stream-constant object @dots{}\n"
"Returns a newly-allocated stream containing in its elements the\n"
"@var{object}s, repeating in succession forever."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4022
msgid ""
"@example\n"
"(stream-constant 1) @result{} 1 1 1 @dots{}\n"
"(stream-constant #t #f) @result{} #t #f #t #f #t #f @dots{}\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4032
msgid ""
"@deffn {Scheme Procedure} stream-drop n stream\n"
"Returns the suffix of the input @var{stream} that starts at the next\n"
"element after the first @var{n} elements.  The output stream shares\n"
"structure with the input @var{stream}; thus, promises forced in one\n"
"instance of the stream are also forced in the other instance of the\n"
"stream.  If the input @var{stream} has less than @var{n} elements,\n"
"@code{stream-drop} returns the null stream.  See also\n"
"@code{stream-take}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4039
msgid ""
"@deffn {Scheme Procedure} stream-drop-while pred stream\n"
"Returns the suffix of the input @var{stream} that starts at the first\n"
"element @var{x} for which @code{(pred x)} returns false.  The output\n"
"stream shares structure with the input @var{stream}.  See also\n"
"@code{stream-take-while}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4044
msgid ""
"@deffn {Scheme Procedure} stream-filter pred stream\n"
"Returns a newly-allocated stream that contains only those elements\n"
"@var{x} of the input @var{stream} which satisfy the predicate\n"
"@code{pred}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4050
msgid ""
"@example\n"
"(stream-filter odd? (stream-from 0))\n"
"   @result{} 1 3 5 7 9 @dots{}\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4065
msgid ""
"@deffn {Scheme Procedure} stream-fold proc base stream\n"
"Applies a binary procedure @var{proc} to @var{base} and the first\n"
"element of @var{stream} to compute a new @var{base}, then applies the\n"
"procedure to the new @var{base} and the next element of @var{stream} to\n"
"compute a succeeding @var{base}, and so on, accumulating a value that is\n"
"finally returned as the value of @code{stream-fold} when the end of the\n"
"stream is reached.  @var{stream} must be finite, or @code{stream-fold}\n"
"will enter an infinite loop.  See also @code{stream-scan}, which is\n"
"similar to @code{stream-fold}, but useful for infinite streams.  For\n"
"readers familiar with other functional languages, this is a left-fold;\n"
"there is no corresponding right-fold, since right-fold relies on finite\n"
"streams that are fully-evaluated, in which case they may as well be\n"
"converted to a list.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4072
msgid ""
"@deffn {Scheme Procedure} stream-for-each proc stream @dots{}\n"
"Applies @var{proc} element-wise to corresponding elements of the input\n"
"@var{stream}s for side-effects; it returns nothing.\n"
"@code{stream-for-each} stops as soon as any of its input streams is\n"
"exhausted.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4081
msgid ""
"@deffn {Scheme Procedure} stream-from first [step]\n"
"Creates a newly-allocated stream that contains @var{first} as its first\n"
"element and increments each succeeding element by @var{step}.  If\n"
"@var{step} is not given it defaults to 1.  @var{first} and @var{step}\n"
"may be of any numeric type.  @code{stream-from} is frequently useful as\n"
"a generator in @code{stream-of} expressions.  See also\n"
"@code{stream-range} for a similar procedure that creates finite streams.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4088
msgid ""
"@deffn {Scheme Procedure} stream-iterate proc base\n"
"Creates a newly-allocated stream containing @var{base} in its first\n"
"element and applies @var{proc} to each element in turn to determine the\n"
"succeeding element.  See also @code{stream-unfold} and\n"
"@code{stream-unfolds}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4094
msgid ""
"@deffn {Scheme Procedure} stream-length stream\n"
"Returns the number of elements in the @var{stream}; it does not evaluate\n"
"its elements.  @code{stream-length} may only be used on finite streams;\n"
"it enters an infinite loop with infinite streams.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4106
msgid ""
"@deffn {Scheme Syntax} stream-let tag ((var expr) @dots{}) body @dots{}\n"
"Creates a local scope that binds each variable to the value of its\n"
"corresponding expression.  It additionally binds @var{tag} to a\n"
"procedure which takes the bound variables as arguments and @var{body} as\n"
"its defining expressions, binding the @var{tag} with\n"
"@code{stream-lambda}.  @var{tag} is in scope within body, and may be\n"
"called recursively.  When the expanded expression defined by the\n"
"@code{stream-let} is evaluated, @code{stream-let} evaluates the\n"
"expressions in its @var{body} in an environment containing the\n"
"newly-bound variables, returning the value of the last expression\n"
"evaluated, which must yield a stream."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4112
msgid ""
"@code{stream-let} provides syntactic sugar on @code{stream-lambda}, in\n"
"the same manner as normal @code{let} provides syntactic sugar on normal\n"
"@code{lambda}.  However, unlike normal @code{let}, the @var{tag} is\n"
"required, not optional, because unnamed @code{stream-let} is\n"
"meaningless."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4117
msgid ""
"For example, @code{stream-member} returns the first @code{stream-pair}\n"
"of the input @var{strm} with a @code{stream-car} @var{x} that satisfies\n"
"@code{(eql? obj x)}, or the null stream if @var{x} is not present in\n"
"@var{strm}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4126
msgid ""
"@example\n"
"(define-stream (stream-member eql? obj strm)\n"
"  (stream-let loop ((strm strm))\n"
"    (cond ((stream-null? strm) strm)\n"
"          ((eql? obj (stream-car strm)) strm)\n"
"          (else (loop (stream-cdr strm))))))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4134
msgid ""
"@deffn {Scheme Procedure} stream-map proc stream @dots{}\n"
"Applies @var{proc} element-wise to corresponding elements of the input\n"
"@var{stream}s, returning a newly-allocated stream containing elements\n"
"that are the results of those procedure applications.  The output stream\n"
"has as many elements as the minimum-length input stream, and may be\n"
"infinite.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4142
msgid ""
"@deffn {Scheme Syntax} stream-match stream clause @dots{}\n"
"Provides pattern-matching for streams.  The input @var{stream} is an\n"
"expression that evaluates to a stream.  Clauses are of the form\n"
"@code{(pattern [fender] expression)}, consisting of a @var{pattern} that\n"
"matches a stream of a particular shape, an optional @var{fender} that\n"
"must succeed if the pattern is to match, and an @var{expression} that is\n"
"evaluated if the pattern matches.  There are four types of patterns:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4146
msgid ""
"@itemize @bullet\n"
"@item\n"
"() matches the null stream."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4150
msgid ""
"@item\n"
"(@var{pat0} @var{pat1} @dots{}) matches a finite stream with length\n"
"exactly equal to the number of pattern elements."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4155
msgid ""
"@item\n"
"(@var{pat0} @var{pat1} @dots{} @code{.} @var{pat-rest}) matches an\n"
"infinite stream, or a finite stream with length at least as great as the\n"
"number of pattern elements before the literal dot."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4161
msgid ""
"@item\n"
"@var{pat} matches an entire stream.  Should always appear last in the\n"
"list of clauses; it's not an error to appear elsewhere, but subsequent\n"
"clauses could never match.\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4163
msgid "Each pattern element may be either:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4171
msgid ""
"@itemize @bullet\n"
"@item\n"
"An identifier, which matches any stream element.  Additionally, the\n"
"value of the stream element is bound to the variable named by the\n"
"identifier, which is in scope in the @var{fender} and @var{expression}\n"
"of the corresponding @var{clause}.  Each identifier in a single pattern\n"
"must be unique."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4176
msgid ""
"@item\n"
"A literal underscore (@code{_}), which matches any stream element but\n"
"creates no bindings.\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4184
msgid ""
"The @var{pattern}s are tested in order, left-to-right, until a matching\n"
"pattern is found; if @var{fender} is present, it must evaluate to a true\n"
"value for the match to be successful.  Pattern variables are bound in\n"
"the corresponding @var{fender} and @var{expression}.  Once the matching\n"
"@var{pattern} is found, the corresponding @var{expression} is evaluated\n"
"and returned as the result of the match.  An error is signaled if no\n"
"pattern matches the input @var{stream}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4187
msgid ""
"@code{stream-match} is often used to distinguish null streams from\n"
"non-null streams, binding @var{head} and @var{tail}:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4194
msgid ""
"@example\n"
"(define (len strm)\n"
"  (stream-match strm\n"
"    (() 0)\n"
"    ((head . tail) (+ 1 (len tail)))))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4198
msgid ""
"Fenders can test the common case where two stream elements must be\n"
"identical; the @code{else} pattern is an identifier bound to the entire\n"
"stream, not a keyword as in @code{cond}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4204
msgid ""
"@example\n"
"(stream-match strm\n"
"  ((x y . _) (equal? x y) 'ok)\n"
"  (else 'error))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4208
msgid ""
"A more complex example uses two nested matchers to match two different\n"
"stream arguments; @code{(stream-merge lt? . strms)} stably merges two or\n"
"more streams ordered by the @code{lt?} predicate:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4225
msgid ""
"@example\n"
"(define-stream (stream-merge lt? . strms)\n"
"  (define-stream (merge xx yy)\n"
"    (stream-match xx (() yy) ((x . xs)\n"
"      (stream-match yy (() xx) ((y . ys)\n"
"        (if (lt? y x)\n"
"            (stream-cons y (merge xx ys))\n"
"            (stream-cons x (merge xs yy))))))))\n"
"  (stream-let loop ((strms strms))\n"
"    (cond ((null? strms) stream-null)\n"
"          ((null? (cdr strms)) (car strms))\n"
"          (else (merge (car strms)\n"
"                       (apply stream-merge lt?\n"
"                         (cdr strms)))))))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4230
msgid ""
"@deffn {Scheme Syntax} stream-of expr clause @dots{}\n"
"Provides the syntax of stream comprehensions, which generate streams by\n"
"means of looping expressions.  The result is a stream of objects of the\n"
"type returned by @var{expr}.  There are four types of clauses:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4238
msgid ""
"@itemize @bullet\n"
"@item\n"
"(@var{var} @code{in} @var{stream-expr}) loops over the elements of\n"
"@var{stream-expr}, in order from the start of the stream, binding each\n"
"element of the stream in turn to @var{var}.  @code{stream-from} and\n"
"@code{stream-range} are frequently useful as generators for\n"
"@var{stream-expr}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4242
msgid ""
"@item\n"
"(@var{var} @code{is} @var{expr}) binds @var{var} to the value obtained\n"
"by evaluating @var{expr}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4247
msgid ""
"@item\n"
"(@var{pred} @var{expr}) includes in the output stream only those\n"
"elements @var{x} which satisfy the predicate @var{pred}.\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4251
msgid ""
"The scope of variables bound in the stream comprehension is the clauses\n"
"to the right of the binding clause (but not the binding clause itself)\n"
"plus the result expression."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4259
msgid ""
"When two or more generators are present, the loops are processed as if\n"
"they are nested from left to right; that is, the rightmost generator\n"
"varies fastest.  A consequence of this is that only the first generator\n"
"may be infinite and all subsequent generators must be finite.  If no\n"
"generators are present, the result of a stream comprehension is a stream\n"
"containing the result expression; thus, @samp{(stream-of 1)} produces a\n"
"finite stream containing only the element 1."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4265
msgid ""
"@example\n"
"(stream-of (* x x)\n"
"  (x in (stream-range 0 10))\n"
"  (even? x))\n"
"  @result{} 0 4 16 36 64"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4270
msgid ""
"(stream-of (list a b)\n"
"  (a in (stream-range 1 4))\n"
"  (b in (stream-range 1 3)))\n"
"  @result{} (1 1) (1 2) (2 1) (2 2) (3 1) (3 2)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4277
msgid ""
"(stream-of (list i j)\n"
"  (i in (stream-range 1 5))\n"
"  (j in (stream-range (+ i 1) 5)))\n"
"  @result{} (1 2) (1 3) (1 4) (2 3) (2 4) (3 4)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4288
msgid ""
"@deffn {Scheme Procedure} stream-range first past [step]\n"
"Creates a newly-allocated stream that contains @var{first} as its first\n"
"element and increments each succeeding element by @var{step}.  The\n"
"stream is finite and ends before @var{past}, which is not an element of\n"
"the stream.  If @var{step} is not given it defaults to 1 if @var{first}\n"
"is less than past and -1 otherwise.  @var{first}, @var{past} and\n"
"@var{step} may be of any real numeric type.  @code{stream-range} is\n"
"frequently useful as a generator in @code{stream-of} expressions.  See\n"
"also @code{stream-from} for a similar procedure that creates infinite\n"
"streams."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4293
msgid ""
"@example\n"
"(stream-range 0 10) @result{} 0 1 2 3 4 5 6 7 8 9\n"
"(stream-range 0 10 2) @result{} 0 2 4 6 8\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4299
msgid ""
"Successive elements of the stream are calculated by adding @var{step} to\n"
"@var{first}, so if any of @var{first}, @var{past} or @var{step} are\n"
"inexact, the length of the output stream may differ from\n"
"@code{(ceiling (- (/ (- past first) step) 1)}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4303
msgid ""
"@deffn {Scheme Procedure} stream-ref stream n\n"
"Returns the @var{n}th element of stream, counting from zero.  An error\n"
"is signaled if @var{n} is greater than or equal to the length of stream."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4311
msgid ""
"@example\n"
"(define (fact n)\n"
"  (stream-ref\n"
"    (stream-scan * 1 (stream-from 1))\n"
"    n))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4319
msgid ""
"@deffn {Scheme Procedure} stream-reverse stream\n"
"Returns a newly-allocated stream containing the elements of the input\n"
"@var{stream} but in reverse order.  @code{stream-reverse} may only be\n"
"used with finite streams; it enters an infinite loop with infinite\n"
"streams.  @code{stream-reverse} does not force evaluation of the\n"
"elements of the stream.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4325
msgid ""
"@deffn {Scheme Procedure} stream-scan proc base stream\n"
"Accumulates the partial folds of an input @var{stream} into a\n"
"newly-allocated output stream.  The output stream is the @var{base}\n"
"followed by @code{(stream-fold proc base (stream-take i stream))} for\n"
"each of the first @var{i} elements of @var{stream}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4329
msgid ""
"@example\n"
"(stream-scan + 0 (stream-from 1))\n"
"  @result{} (stream 0 1 3 6 10 15 @dots{})"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4334
msgid ""
"(stream-scan * 1 (stream-from 1))\n"
"  @result{} (stream 1 1 2 6 24 120 @dots{})\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4341
msgid ""
"@deffn {Scheme Procedure} stream-take n stream\n"
"Returns a newly-allocated stream containing the first @var{n} elements\n"
"of the input @var{stream}.  If the input @var{stream} has less than\n"
"@var{n} elements, so does the output stream.  See also\n"
"@code{stream-drop}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4348
msgid ""
"@deffn {Scheme Procedure} stream-take-while pred stream\n"
"Takes a predicate and a @code{stream} and returns a newly-allocated\n"
"stream containing those elements @code{x} that form the maximal prefix\n"
"of the input stream which satisfy @var{pred}.  See also\n"
"@code{stream-drop-while}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4356
msgid ""
"@deffn {Scheme Procedure} stream-unfold map pred gen base\n"
"The fundamental recursive stream constructor.  It constructs a stream by\n"
"repeatedly applying @var{gen} to successive values of @var{base}, in the\n"
"manner of @code{stream-iterate}, then applying @var{map} to each of the\n"
"values so generated, appending each of the mapped values to the output\n"
"stream as long as @code{(pred? base)} returns a true value.  See also\n"
"@code{stream-iterate} and @code{stream-unfolds}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4365
msgid ""
"The expression below creates the finite stream @samp{0 1 4 9 16 25 36 49\n"
"64 81}.  Initially the @var{base} is 0, which is less than 10, so\n"
"@var{map} squares the @var{base} and the mapped value becomes the first\n"
"element of the output stream.  Then @var{gen} increments the @var{base}\n"
"by 1, so it becomes 1; this is less than 10, so @var{map} squares the\n"
"new @var{base} and 1 becomes the second element of the output stream.\n"
"And so on, until the base becomes 10, when @var{pred} stops the\n"
"recursion and stream-null ends the output stream."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4374
msgid ""
"@example\n"
"(stream-unfold\n"
"  (lambda (x) (expt x 2)) ; map\n"
"  (lambda (x) (< x 10))   ; pred?\n"
"  (lambda (x) (+ x 1))    ; gen\n"
"  0)                      ; base\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4379
msgid ""
"@deffn {Scheme Procedure} stream-unfolds proc seed\n"
"Returns @var{n} newly-allocated streams containing those elements\n"
"produced by successive calls to the generator @var{proc}, which takes\n"
"the current @var{seed} as its argument and returns @var{n}+1 values"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4381
msgid ""
"(@var{proc} @var{seed}) @result{} @var{seed} @var{result_0} @dots{} "
"@var{result_n-1}"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4385
msgid ""
"where the returned @var{seed} is the input @var{seed} to the next call\n"
"to the generator and @var{result_i} indicates how to produce the next\n"
"element of the @var{i}th result stream:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4389
msgid ""
"@itemize @bullet\n"
"@item\n"
"(@var{value}): @var{value} is the next car of the result stream."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4393
msgid ""
"@item\n"
"@code{#f}: no value produced by this iteration of the generator\n"
"@var{proc} for the result stream."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4397
msgid ""
"@item\n"
"(): the end of the result stream.\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4401
msgid ""
"It may require multiple calls of @var{proc} to produce the next element\n"
"of any particular result stream.  See also @code{stream-iterate} and\n"
"@code{stream-unfold}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4414
msgid ""
"@example\n"
"(define (stream-partition pred? strm)\n"
"  (stream-unfolds\n"
"    (lambda (s)\n"
"      (if (stream-null? s)\n"
"          (values s '() '())\n"
"          (let ((a (stream-car s))\n"
"                (d (stream-cdr s)))\n"
"            (if (pred? a)\n"
"                (values d (list a) #f)\n"
"                (values d #f (list a))))))\n"
"    strm))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4425
msgid ""
"(call-with-values\n"
"  (lambda ()\n"
"    (stream-partition odd?\n"
"      (stream-range 1 6)))\n"
"  (lambda (odds evens)\n"
"    (list (stream->list odds)\n"
"          (stream->list evens))))\n"
"  @result{} ((1 3 5) (2 4))\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4433
msgid ""
"@deffn {Scheme Procedure} stream-zip stream @dots{}\n"
"Returns a newly-allocated stream in which each element is a list (not a\n"
"stream) of the corresponding elements of the input @var{stream}s.  The\n"
"output stream is as long as the shortest input @var{stream}, if any of\n"
"the input @var{stream}s is finite, or is infinite if all the input\n"
"@var{stream}s are infinite.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4437
msgid ""
"@node SRFI-42\n"
"@subsection SRFI-42 - Eager Comprehensions\n"
"@cindex SRFI-42"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4440
msgid ""
"See @uref{http://srfi.schemers.org/srfi-42/srfi-42.html, the\n"
"specification of SRFI-42}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4444
msgid ""
"@node SRFI-43\n"
"@subsection SRFI-43 - Vector Library\n"
"@cindex SRFI-43"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4448
msgid ""
"This subsection is based on the\n"
"@uref{http://srfi.schemers.org/srfi-43/srfi-43.html, specification of\n"
"SRFI-43} by Taylor Campbell."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4451
msgid ""
"@c The copyright notice and license text of the SRFI-43 specification is\n"
"@c reproduced below:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4453
msgid "@c Copyright (C) Taylor Campbell (2003). All Rights Reserved."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4461
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:4461"
msgid ""
"@c Permission is hereby granted, free of charge, to any person obtaining a\n"
"@c copy of this software and associated documentation files (the\n"
"@c \"Software\"), to deal in the Software without restriction, including\n"
"@c without limitation the rights to use, copy, modify, merge, publish,\n"
"@c distribute, sublicense, and/or sell copies of the Software, and to\n"
"@c permit persons to whom the Software is furnished to do so, subject to\n"
"@c the following conditions:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4464
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:4464"
msgid ""
"@c The above copyright notice and this permission notice shall be included\n"
"@c in all copies or substantial portions of the Software."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4472
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:4472"
msgid ""
"@c THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, "
"EXPRESS\n"
"@c OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
"@c MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n"
"@c NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n"
"@c LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n"
"@c OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n"
"@c WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4476
msgid ""
"@noindent\n"
"SRFI-43 implements a comprehensive library of vector operations.  It can\n"
"be made available with:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4480
msgid ""
"@example\n"
"(use-modules (srfi srfi-43))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4490
msgid ""
"@menu\n"
"* SRFI-43 Constructors::\n"
"* SRFI-43 Predicates::\n"
"* SRFI-43 Selectors::\n"
"* SRFI-43 Iteration::\n"
"* SRFI-43 Searching::\n"
"* SRFI-43 Mutators::\n"
"* SRFI-43 Conversion::\n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4493
msgid ""
"@node SRFI-43 Constructors\n"
"@subsubsection SRFI-43 Constructors"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4497
msgid ""
"@deffn {Scheme Procedure} make-vector size [fill]\n"
"Create and return a vector of size @var{size}, optionally filling it\n"
"with @var{fill}.  The default value of @var{fill} is unspecified."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4502
msgid ""
"@example\n"
"(make-vector 5 3) @result{} #(3 3 3 3 3)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4505
msgid ""
"@deffn {Scheme Procedure} vector x @dots{}\n"
"Create and return a vector whose elements are @var{x} @enddots{}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4510
msgid ""
"@example\n"
"(vector 0 1 2 3 4) @result{} #(0 1 2 3 4)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4519
msgid ""
"@deffn {Scheme Procedure} vector-unfold f length initial-seed @dots{}\n"
"The fundamental vector constructor.  Create a vector whose length\n"
"is @var{length} and iterates across each index k from 0 up to\n"
"@var{length} - 1, applying @var{f} at each iteration to the current\n"
"index and current seeds, in that order, to receive n + 1 values: the\n"
"element to put in the kth slot of the new vector, and n new seeds for\n"
"the next iteration.  It is an error for the number of seeds to vary\n"
"between iterations."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4524
msgid ""
"@example\n"
"(vector-unfold (lambda (i x) (values x (- x 1)))\n"
"               10 0)\n"
"@result{} #(0 -1 -2 -3 -4 -5 -6 -7 -8 -9)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4529
msgid ""
"(vector-unfold values 10)\n"
"@result{} #(0 1 2 3 4 5 6 7 8 9)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4533
msgid ""
"@deffn {Scheme Procedure} vector-unfold-right f length initial-seed @dots{}\n"
"Like @code{vector-unfold}, but it uses @var{f} to generate elements from\n"
"right-to-left, rather than left-to-right."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4540
msgid ""
"@example\n"
"(vector-unfold-right (lambda (i x) (values x (+ x 1)))\n"
"                     10 0)\n"
"@result{} #(9 8 7 6 5 4 3 2 1 0)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4550
msgid ""
"@deffn {Scheme Procedure} vector-copy vec [start [end [fill]]]\n"
"Allocate a new vector whose length is @var{end} - @var{start} and fills\n"
"it with elements from @var{vec}, taking elements from @var{vec} starting\n"
"at index @var{start} and stopping at index @var{end}.  @var{start}\n"
"defaults to 0 and @var{end} defaults to the value of\n"
"@code{(vector-length vec)}.  If @var{end} extends beyond the length of\n"
"@var{vec}, the slots in the new vector that obviously cannot be filled\n"
"by elements from @var{vec} are filled with @var{fill}, whose default\n"
"value is unspecified."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4554
msgid ""
"@example\n"
"(vector-copy '#(a b c d e f g h i))\n"
"@result{} #(a b c d e f g h i)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4557
msgid ""
"(vector-copy '#(a b c d e f g h i) 6)\n"
"@result{} #(g h i)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4560
msgid ""
"(vector-copy '#(a b c d e f g h i) 3 6)\n"
"@result{} #(d e f)"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4565
msgid ""
"(vector-copy '#(a b c d e f g h i) 6 12 'x)\n"
"@result{} #(g h i x x x)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4569
msgid ""
"@deffn {Scheme Procedure} vector-reverse-copy vec [start [end]]\n"
"Like @code{vector-copy}, but it copies the elements in the reverse order\n"
"from @var{vec}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4575
msgid ""
"@example\n"
"(vector-reverse-copy '#(5 4 3 2 1 0) 1 5)\n"
"@result{} #(1 2 3 4)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4579
msgid ""
"@deffn {Scheme Procedure} vector-append vec @dots{}\n"
"Return a newly allocated vector that contains all elements in order from\n"
"the subsequent locations in @var{vec} @enddots{}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4585
msgid ""
"@example\n"
"(vector-append '#(a) '#(b c d))\n"
"@result{} #(a b c d)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4589
msgid ""
"@deffn {Scheme Procedure} vector-concatenate list-of-vectors\n"
"Append each vector in @var{list-of-vectors}.  Equivalent to\n"
"@code{(apply vector-append list-of-vectors)}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4595
msgid ""
"@example\n"
"(vector-concatenate '(#(a b) #(c d)))\n"
"@result{} #(a b c d)\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4598
msgid ""
"@node SRFI-43 Predicates\n"
"@subsubsection SRFI-43 Predicates"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4602
msgid ""
"@deffn {Scheme Procedure} vector? obj\n"
"Return true if @var{obj} is a vector, else return false.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4607
msgid ""
"@deffn {Scheme Procedure} vector-empty? vec\n"
"Return true if @var{vec} is empty, i.e. its length is 0, else return\n"
"false.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4616
msgid ""
"@deffn {Scheme Procedure} vector= elt=? vec @dots{}\n"
"Return true if the vectors @var{vec} @dots{} have equal lengths and\n"
"equal elements according to @var{elt=?}.  @var{elt=?} is always applied\n"
"to two arguments.  Element comparison must be consistent with @code{eq?}\n"
"in the following sense: if @code{(eq? a b)} returns true, then\n"
"@code{(elt=? a b)} must also return true.  The order in which\n"
"comparisons are performed is unspecified.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4619
msgid ""
"@node SRFI-43 Selectors\n"
"@subsubsection SRFI-43 Selectors"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4624
msgid ""
"@deffn {Scheme Procedure} vector-ref vec i\n"
"Return the element at index @var{i} in @var{vec}.  Indexing is based on\n"
"zero.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4628
msgid ""
"@deffn {Scheme Procedure} vector-length vec\n"
"Return the length of @var{vec}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4631
msgid ""
"@node SRFI-43 Iteration\n"
"@subsubsection SRFI-43 Iteration"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4644
msgid ""
"@deffn {Scheme Procedure} vector-fold kons knil vec1 vec2 @dots{}\n"
"The fundamental vector iterator.  @var{kons} is iterated over each index\n"
"in all of the vectors, stopping at the end of the shortest; @var{kons}\n"
"is applied as\n"
"@smalllisp\n"
"(kons i state (vector-ref vec1 i) (vector-ref vec2 i) ...)\n"
"@end smalllisp\n"
"where @var{state} is the current state value, and @var{i} is the current\n"
"index.  The current state value begins with @var{knil}, and becomes\n"
"whatever @var{kons} returned at the respective iteration.  The iteration\n"
"is strictly left-to-right.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4649
msgid ""
"@deffn {Scheme Procedure} vector-fold-right kons knil vec1 vec2 @dots{}\n"
"Similar to @code{vector-fold}, but it iterates right-to-left instead of\n"
"left-to-right.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4658
msgid ""
"@deffn {Scheme Procedure} vector-map f vec1 vec2 @dots{}\n"
"Return a new vector of the shortest size of the vector arguments.  Each\n"
"element at index i of the new vector is mapped from the old vectors by\n"
"@smalllisp\n"
"(f i (vector-ref vec1 i) (vector-ref vec2 i) ...)\n"
"@end smalllisp\n"
"The dynamic order of application of @var{f} is unspecified.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4665
msgid ""
"@deffn {Scheme Procedure} vector-map! f vec1 vec2 @dots{}\n"
"Similar to @code{vector-map}, but rather than mapping the new elements\n"
"into a new vector, the new mapped elements are destructively inserted\n"
"into @var{vec1}.  The dynamic order of application of @var{f} is\n"
"unspecified.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4671
msgid ""
"@deffn {Scheme Procedure} vector-for-each f vec1 vec2 @dots{}\n"
"Call @code{(f i (vector-ref vec1 i) (vector-ref vec2 i) ...)} for each\n"
"index i less than the length of the shortest vector passed.  The\n"
"iteration is strictly left-to-right.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4677
msgid ""
"@deffn {Scheme Procedure} vector-count pred? vec1 vec2 @dots{}\n"
"Count the number of parallel elements in the vectors that satisfy\n"
"@var{pred?}, which is applied, for each index i less than the length of\n"
"the smallest vector, to i and each parallel element in the vectors at\n"
"that index, in order."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4687
msgid ""
"@example\n"
"(vector-count (lambda (i elt) (even? elt))\n"
"              '#(3 1 4 1 5 9 2 5 6))\n"
"@result{} 3\n"
"(vector-count (lambda (i x y) (< x y))\n"
"              '#(1 3 6 9) '#(2 4 6 8 10 12))\n"
"@result{} 2\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4690
msgid ""
"@node SRFI-43 Searching\n"
"@subsubsection SRFI-43 Searching"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4695
msgid ""
"@deffn {Scheme Procedure} vector-index pred? vec1 vec2 @dots{}\n"
"Find and return the index of the first elements in @var{vec1} @var{vec2}\n"
"@dots{} that satisfy @var{pred?}.  If no matching element is found by\n"
"the end of the shortest vector, return @code{#f}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4705
msgid ""
"@example\n"
"(vector-index even? '#(3 1 4 1 5 9))\n"
"@result{} 2\n"
"(vector-index < '#(3 1 4 1 5 9 2 5 6) '#(2 7 1 8 2))\n"
"@result{} 1\n"
"(vector-index = '#(3 1 4 1 5 9 2 5 6) '#(2 7 1 8 2))\n"
"@result{} #f\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4713
msgid ""
"@deffn {Scheme Procedure} vector-index-right pred? vec1 vec2 @dots{}\n"
"Like @code{vector-index}, but it searches right-to-left, rather than\n"
"left-to-right.  Note that the SRFI 43 specification requires that all\n"
"the vectors must have the same length, but both the SRFI 43 reference\n"
"implementation and Guile's implementation allow vectors with unequal\n"
"lengths, and start searching from the last index of the shortest vector.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4719
msgid ""
"@deffn {Scheme Procedure} vector-skip pred? vec1 vec2 @dots{}\n"
"Find and return the index of the first elements in @var{vec1} @var{vec2}\n"
"@dots{} that do not satisfy @var{pred?}.  If no matching element is\n"
"found by the end of the shortest vector, return @code{#f}.  Equivalent\n"
"to @code{vector-index} but with the predicate inverted."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4724
msgid ""
"@example\n"
"(vector-skip number? '#(1 2 a b 3 4 c d)) @result{} 2\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4733
msgid ""
"@deffn {Scheme Procedure} vector-skip-right pred? vec1 vec2 @dots{}\n"
"Like @code{vector-skip}, but it searches for a non-matching element\n"
"right-to-left, rather than left-to-right.  Note that the SRFI 43\n"
"specification requires that all the vectors must have the same length,\n"
"but both the SRFI 43 reference implementation and Guile's implementation\n"
"allow vectors with unequal lengths, and start searching from the last\n"
"index of the shortest vector.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4739
msgid ""
"@deffn {Scheme Procedure} vector-binary-search vec value cmp [start [end]]\n"
"Find and return an index of @var{vec} between @var{start} and @var{end}\n"
"whose value is @var{value} using a binary search.  If no matching\n"
"element is found, return @code{#f}.  The default @var{start} is 0 and\n"
"the default @var{end} is the length of @var{vec}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4744
msgid ""
"@var{cmp} must be a procedure of two arguments such that @code{(cmp a\n"
"b)} returns a negative integer if @math{a < b}, a positive integer if\n"
"@math{a > b}, or zero if @math{a = b}.  The elements of @var{vec} must\n"
"be sorted in non-decreasing order according to @var{cmp}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4748
msgid ""
"Note that SRFI 43 does not document the @var{start} and @var{end}\n"
"arguments, but both its reference implementation and Guile's\n"
"implementation support them."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4754
msgid ""
"@example\n"
"(define (char-cmp c1 c2)\n"
"  (cond ((char<? c1 c2) -1)\n"
"        ((char>? c1 c2) 1)\n"
"        (else 0)))"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4761
msgid ""
"(vector-binary-search '#(#\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\h)\n"
"                      #\\g\n"
"                      char-cmp)\n"
"@result{} 6\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4769
msgid ""
"@deffn {Scheme Procedure} vector-any pred? vec1 vec2 @dots{}\n"
"Find the first parallel set of elements from @var{vec1} @var{vec2}\n"
"@dots{} for which @var{pred?} returns a true value.  If such a parallel\n"
"set of elements exists, @code{vector-any} returns the value that\n"
"@var{pred?} returned for that set of elements.  The iteration is\n"
"strictly left-to-right.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4779
msgid ""
"@deffn {Scheme Procedure} vector-every pred? vec1 vec2 @dots{}\n"
"If, for every index i between 0 and the length of the shortest vector\n"
"argument, the set of elements @code{(vector-ref vec1 i)}\n"
"@code{(vector-ref vec2 i)} @dots{} satisfies @var{pred?},\n"
"@code{vector-every} returns the value that @var{pred?} returned for the\n"
"last set of elements, at the last index of the shortest vector.\n"
"Otherwise it returns @code{#f}.  The iteration is strictly\n"
"left-to-right.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4782
msgid ""
"@node SRFI-43 Mutators\n"
"@subsubsection SRFI-43 Mutators"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4787
msgid ""
"@deffn {Scheme Procedure} vector-set! vec i value\n"
"Assign the contents of the location at @var{i} in @var{vec} to\n"
"@var{value}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4791
msgid ""
"@deffn {Scheme Procedure} vector-swap! vec i j\n"
"Swap the values of the locations in @var{vec} at @var{i} and @var{j}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4797
msgid ""
"@deffn {Scheme Procedure} vector-fill! vec fill [start [end]]\n"
"Assign the value of every location in @var{vec} between @var{start} and\n"
"@var{end} to @var{fill}.  @var{start} defaults to 0 and @var{end}\n"
"defaults to the length of @var{vec}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4803
msgid ""
"@deffn {Scheme Procedure} vector-reverse! vec [start [end]]\n"
"Destructively reverse the contents of @var{vec} between @var{start} and\n"
"@var{end}.  @var{start} defaults to 0 and @var{end} defaults to the\n"
"length of @var{vec}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4813
msgid ""
"@deffn {Scheme Procedure} vector-copy! target tstart source [sstart [send]]\n"
"Copy a block of elements from @var{source} to @var{target}, both of\n"
"which must be vectors, starting in @var{target} at @var{tstart} and\n"
"starting in @var{source} at @var{sstart}, ending when (@var{send} -\n"
"@var{sstart}) elements have been copied.  It is an error for\n"
"@var{target} to have a length less than (@var{tstart} + @var{send} -\n"
"@var{sstart}).  @var{sstart} defaults to 0 and @var{send} defaults to\n"
"the length of @var{source}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4821
msgid ""
"@deffn {Scheme Procedure} vector-reverse-copy! target tstart source [sstart "
"[send]]\n"
"Like @code{vector-copy!}, but this copies the elements in the reverse\n"
"order.  It is an error if @var{target} and @var{source} are identical\n"
"vectors and the @var{target} and @var{source} ranges overlap; however,\n"
"if @var{tstart} = @var{sstart}, @code{vector-reverse-copy!} behaves as\n"
"@code{(vector-reverse! target tstart send)} would.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4824
msgid ""
"@node SRFI-43 Conversion\n"
"@subsubsection SRFI-43 Conversion"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4830
msgid ""
"@deffn {Scheme Procedure} vector->list vec [start [end]]\n"
"Return a newly allocated list containing the elements in @var{vec}\n"
"between @var{start} and @var{end}.  @var{start} defaults to 0 and\n"
"@var{end} defaults to the length of @var{vec}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4835
msgid ""
"@deffn {Scheme Procedure} reverse-vector->list vec [start [end]]\n"
"Like @code{vector->list}, but the resulting list contains the specified\n"
"range of elements of @var{vec} in reverse order.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4844
msgid ""
"@deffn {Scheme Procedure} list->vector proper-list [start [end]]\n"
"Return a newly allocated vector of the elements from @var{proper-list}\n"
"with indices between @var{start} and @var{end}.  @var{start} defaults to\n"
"0 and @var{end} defaults to the length of @var{proper-list}.  Note that\n"
"SRFI 43 does not document the @var{start} and @var{end} arguments, but\n"
"both its reference implementation and Guile's implementation support\n"
"them.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4851
msgid ""
"@deffn {Scheme Procedure} reverse-list->vector proper-list [start [end]]\n"
"Like @code{list->vector}, but the resulting vector contains the specified\n"
"range of elements of @var{proper-list} in reverse order.  Note that SRFI\n"
"43 does not document the @var{start} and @var{end} arguments, but both\n"
"its reference implementation and Guile's implementation support them.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4855
msgid ""
"@node SRFI-45\n"
"@subsection SRFI-45 - Primitives for Expressing Iterative Lazy Algorithms\n"
"@cindex SRFI-45"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4858
msgid ""
"This subsection is based on @uref{http://srfi.schemers.org/srfi-45/srfi-"
"45.html, the\n"
"specification of SRFI-45} written by Andr@'e van Tonder."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4860
msgid "@c Copyright (C) Andr van Tonder (2003). All Rights Reserved."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4868
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:4868"
msgid ""
"@c Permission is hereby granted, free of charge, to any person obtaining a\n"
"@c copy of this software and associated documentation files (the\n"
"@c \"Software\"), to deal in the Software without restriction, including\n"
"@c without limitation the rights to use, copy, modify, merge, publish,\n"
"@c distribute, sublicense, and/or sell copies of the Software, and to\n"
"@c permit persons to whom the Software is furnished to do so, subject to\n"
"@c the following conditions:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4871
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:4871"
msgid ""
"@c The above copyright notice and this permission notice shall be included\n"
"@c in all copies or substantial portions of the Software."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4879
msgctxt "/home/bear/work/guile/doc/guile/en/srfi-modules.texi:4879"
msgid ""
"@c THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, "
"EXPRESS\n"
"@c OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n"
"@c MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n"
"@c NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n"
"@c LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n"
"@c OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n"
"@c WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4886
msgid ""
"Lazy evaluation is traditionally simulated in Scheme using @code{delay}\n"
"and @code{force}.  However, these primitives are not powerful enough to\n"
"express a large class of lazy algorithms that are iterative.  Indeed, it\n"
"is folklore in the Scheme community that typical iterative lazy\n"
"algorithms written using delay and force will often require unbounded\n"
"memory."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4893
msgid ""
"This SRFI provides set of three operations: @{@code{lazy}, @code{delay},\n"
"@code{force}@}, which allow the programmer to succinctly express lazy\n"
"algorithms while retaining bounded space behavior in cases that are\n"
"properly tail-recursive.  A general recipe for using these primitives is\n"
"provided. An additional procedure @code{eager} is provided for the\n"
"construction of eager promises in cases where efficiency is a concern."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4901
msgid ""
"Although this SRFI redefines @code{delay} and @code{force}, the\n"
"extension is conservative in the sense that the semantics of the subset\n"
"@{@code{delay}, @code{force}@} in isolation (i.e., as long as the\n"
"program does not use @code{lazy}) agrees with that in R5RS.  In other\n"
"words, no program that uses the R5RS definitions of delay and force will\n"
"break if those definition are replaced by the SRFI-45 definitions of\n"
"delay and force."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4904
msgid ""
"Guile also adds @code{promise?} to the list of exports, which is not\n"
"part of the official SRFI-45."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4908
msgid ""
"@deffn {Scheme Procedure} promise? obj\n"
"Return true if @var{obj} is an SRFI-45 promise, otherwise return false.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4915
msgid ""
"@deffn {Scheme Syntax} delay expression\n"
"Takes an expression of arbitrary type @var{a} and returns a promise of\n"
"type @code{(Promise @var{a})} which at some point in the future may be\n"
"asked (by the @code{force} procedure) to evaluate the expression and\n"
"deliver the resulting value.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4922
msgid ""
"@deffn {Scheme Syntax} lazy expression\n"
"Takes an expression of type @code{(Promise @var{a})} and returns a\n"
"promise of type @code{(Promise @var{a})} which at some point in the\n"
"future may be asked (by the @code{force} procedure) to evaluate the\n"
"expression and deliver the resulting promise.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4930
msgid ""
"@deffn {Scheme Procedure} force expression\n"
"Takes an argument of type @code{(Promise @var{a})} and returns a value\n"
"of type @var{a} as follows: If a value of type @var{a} has been computed\n"
"for the promise, this value is returned.  Otherwise, the promise is\n"
"first evaluated, then overwritten by the obtained promise or value, and\n"
"then force is again applied (iteratively) to the promise.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4936
msgid ""
"@deffn {Scheme Procedure} eager expression\n"
"Takes an argument of type @var{a} and returns a value of type\n"
"@code{(Promise @var{a})}.  As opposed to @code{delay}, the argument is\n"
"evaluated eagerly. Semantically, writing @code{(eager expression)} is\n"
"equivalent to writing"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4940
msgid ""
"@lisp\n"
"(let ((value expression)) (delay value)).\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4944
msgid ""
"However, the former is more efficient since it does not require\n"
"unnecessary creation and evaluation of thunks. We also have the\n"
"equivalence"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4949
msgid ""
"@lisp\n"
"(delay expression) = (lazy (eager expression))\n"
"@end lisp\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4953
msgid ""
"The following reduction rules may be helpful for reasoning about these\n"
"primitives.  However, they do not express the memoization and memory\n"
"usage semantics specified above:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4959
msgid ""
"@lisp\n"
"(force (delay expression)) -> expression\n"
"(force (lazy  expression)) -> (force expression)\n"
"(force (eager value))      -> value\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4961
msgid "@subsubheading Correct usage"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4966
msgid ""
"We now provide a general recipe for using the primitives @{@code{lazy},\n"
"@code{delay}, @code{force}@} to express lazy algorithms in Scheme.  The\n"
"transformation is best described by way of an example: Consider the\n"
"stream-filter algorithm, expressed in a hypothetical lazy language as"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4976
msgid ""
"@lisp\n"
"(define (stream-filter p? s)\n"
"  (if (null? s) '()\n"
"      (let ((h (car s))\n"
"            (t (cdr s)))\n"
"        (if (p? h)\n"
"            (cons h (stream-filter p? t))\n"
"            (stream-filter p? t)))))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4978
msgid "This algorithm can be expressed as follows in Scheme:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4989
msgid ""
"@lisp\n"
"(define (stream-filter p? s)\n"
"  (lazy\n"
"     (if (null? (force s)) (delay '())\n"
"         (let ((h (car (force s)))\n"
"               (t (cdr (force s))))\n"
"           (if (p? h)\n"
"               (delay (cons h (stream-filter p? t)))\n"
"               (stream-filter p? t))))))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:4991
msgid "In other words, we"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5001
msgid ""
"@itemize @bullet\n"
"@item\n"
"wrap all constructors (e.g., @code{'()}, @code{cons}) with @code{delay},\n"
"@item \n"
"apply @code{force} to arguments of deconstructors (e.g., @code{car},\n"
"@code{cdr} and @code{null?}),\n"
"@item\n"
"wrap procedure bodies with @code{(lazy ...)}.\n"
"@end itemize"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5005
msgid ""
"@node SRFI-46\n"
"@subsection SRFI-46 Basic syntax-rules Extensions\n"
"@cindex SRFI-46"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5010
msgid ""
"Guile's core @code{syntax-rules} supports the extensions specified by\n"
"SRFI-46/R7RS.  Tail patterns have been supported since at least Guile\n"
"2.0, and custom ellipsis identifiers have been supported since Guile\n"
"2.0.10.  @xref{Syntax Rules}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5014
msgid ""
"@node SRFI-55\n"
"@subsection SRFI-55 - Requiring Features\n"
"@cindex SRFI-55"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5018
msgid ""
"SRFI-55 provides @code{require-extension} which is a portable\n"
"mechanism to load selected SRFI modules.  This is implemented in the\n"
"Guile core, there's no module needed to get SRFI-55 itself."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5022
msgid ""
"@deffn {library syntax} require-extension clause1 clause2 @dots{}\n"
"Require the features of @var{clause1} @var{clause2} @dots{}  , throwing\n"
"an error if any are unavailable."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5026
msgid ""
"A @var{clause} is of the form @code{(@var{identifier} arg...)}.  The\n"
"only @var{identifier} currently supported is @code{srfi} and the\n"
"arguments are SRFI numbers.  For example to get SRFI-1 and SRFI-6,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5030
msgid ""
"@example\n"
"(require-extension (srfi 1 6))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5032
msgid "@code{require-extension} can only be used at the top-level."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5037
msgid ""
"A Guile-specific program can simply @code{use-modules} to load SRFIs\n"
"not already in the core, @code{require-extension} is for programs\n"
"designed to be portable to other Scheme implementations.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5044
msgid ""
"@node SRFI-60\n"
"@subsection SRFI-60 - Integers as Bits\n"
"@cindex SRFI-60\n"
"@cindex integers as bits\n"
"@cindex bitwise logical"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5047
msgid ""
"This SRFI provides various functions for treating integers as bits and\n"
"for bitwise manipulations.  These functions can be obtained with,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5051
msgid ""
"@example\n"
"(use-modules (srfi srfi-60))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5056
msgid ""
"Integers are treated as infinite precision twos-complement, the same\n"
"as in the core logical functions (@pxref{Bitwise Operations}).  And\n"
"likewise bit indexes start from 0 for the least significant bit.  The\n"
"following functions in this SRFI are already in the Guile core,"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5068
msgid ""
"@quotation\n"
"@code{logand},\n"
"@code{logior},\n"
"@code{logxor},\n"
"@code{lognot},\n"
"@code{logtest},\n"
"@code{logcount},\n"
"@code{integer-length},\n"
"@code{logbit?},\n"
"@code{ash}\n"
"@end quotation"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5082
msgid ""
"@sp 1\n"
"@defun bitwise-and n1 ...\n"
"@defunx bitwise-ior n1 ...\n"
"@defunx bitwise-xor n1 ...\n"
"@defunx bitwise-not n\n"
"@defunx any-bits-set? j k\n"
"@defunx bit-set? index n\n"
"@defunx arithmetic-shift n count\n"
"@defunx bit-field n start end\n"
"@defunx bit-count n\n"
"Aliases for @code{logand}, @code{logior}, @code{logxor},\n"
"@code{lognot}, @code{logtest}, @code{logbit?}, @code{ash},\n"
"@code{bit-extract} and @code{logcount} respectively."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5086
msgid ""
"Note that the name @code{bit-count} conflicts with @code{bit-count} in\n"
"the core (@pxref{Bit Vectors}).\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5093
msgid ""
"@defun bitwise-if mask n1 n0\n"
"@defunx bitwise-merge mask n1 n0\n"
"Return an integer with bits selected from @var{n1} and @var{n0}\n"
"according to @var{mask}.  Those bits where @var{mask} has 1s are taken\n"
"from @var{n1}, and those where @var{mask} has 0s are taken from\n"
"@var{n0}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5098
msgid ""
"@example\n"
"(bitwise-if 3 #b0101 #b1010) @result{} 9\n"
"@end example\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5104
msgid ""
"@defun log2-binary-factors n\n"
"@defunx first-set-bit n\n"
"Return a count of how many factors of 2 are present in @var{n}.  This\n"
"is also the bit index of the lowest 1 bit in @var{n}.  If @var{n} is\n"
"0, the return is @math{-1}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5110
msgid ""
"@example\n"
"(log2-binary-factors 6) @result{} 1\n"
"(log2-binary-factors -8) @result{} 3\n"
"@end example\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5116
msgid ""
"@defun copy-bit index n newbit\n"
"Return @var{n} with the bit at @var{index} set according to\n"
"@var{newbit}.  @var{newbit} should be @code{#t} to set the bit to 1,\n"
"or @code{#f} to set it to 0.  Bits other than at @var{index} are\n"
"unchanged in the return."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5121
msgid ""
"@example\n"
"(copy-bit 1 #b0101 #t) @result{} 7\n"
"@end example\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5125
msgid ""
"@defun copy-bit-field n newbits start end\n"
"Return @var{n} with the bits from @var{start} (inclusive) to @var{end}\n"
"(exclusive) changed to the value @var{newbits}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5129
msgid ""
"The least significant bit in @var{newbits} goes to @var{start}, the\n"
"next to @math{@var{start}+1}, etc.  Anything in @var{newbits} past the\n"
"@var{end} given is ignored."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5134
msgid ""
"@example\n"
"(copy-bit-field #b10000 #b11 1 3) @result{} #b10110\n"
"@end example\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5138
msgid ""
"@defun rotate-bit-field n count start end\n"
"Return @var{n} with the bit field from @var{start} (inclusive) to\n"
"@var{end} (exclusive) rotated upwards by @var{count} bits."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5141
msgid ""
"@var{count} can be positive or negative, and it can be more than the\n"
"field width (it'll be reduced modulo the width)."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5146
msgid ""
"@example\n"
"(rotate-bit-field #b0110 2 1 4) @result{} #b1010\n"
"@end example\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5150
msgid ""
"@defun reverse-bit-field n start end\n"
"Return @var{n} with the bits from @var{start} (inclusive) to @var{end}\n"
"(exclusive) reversed."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5155
msgid ""
"@example\n"
"(reverse-bit-field #b101001 2 4) @result{} #b100101\n"
"@end example\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5162
msgid ""
"@defun integer->list n [len]\n"
"Return bits from @var{n} in the form of a list of @code{#t} for 1 and\n"
"@code{#f} for 0.  The least significant @var{len} bits are returned,\n"
"and the first list element is the most significant of those bits.  If\n"
"@var{len} is not given, the default is @code{(integer-length @var{n})}\n"
"(@pxref{Bitwise Operations})."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5168
msgid ""
"@example\n"
"(integer->list 6)   @result{} (#t #t #f)\n"
"(integer->list 1 4) @result{} (#f #f #f #t)\n"
"@end example\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5174
msgid ""
"@defun list->integer lst\n"
"@defunx booleans->integer bool@dots{}\n"
"Return an integer formed bitwise from the given @var{lst} list of\n"
"booleans, or for @code{booleans->integer} from the @var{bool}\n"
"arguments."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5177
msgid ""
"Each boolean is @code{#t} for a 1 and @code{#f} for a 0.  The first\n"
"element becomes the most significant bit in the return."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5182
msgid ""
"@example\n"
"(list->integer '(#t #f #t #f)) @result{} 10\n"
"@end example\n"
"@end defun"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5186
msgid ""
"@node SRFI-61\n"
"@subsection SRFI-61 - A more general @code{cond} clause"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5192
msgid ""
"This SRFI extends RnRS @code{cond} to support test expressions that\n"
"return multiple values, as well as arbitrary definitions of test\n"
"success.  SRFI 61 is implemented in the Guile core; there's no module\n"
"needed to get SRFI-61 itself.  Extended @code{cond} is documented in\n"
"@ref{Conditionals,, Simple Conditional Evaluation}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5196
msgid ""
"@node SRFI-62\n"
"@subsection SRFI-62 - S-expression comments.\n"
"@cindex SRFI-62"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5199
msgid ""
"Starting from version 2.0, Guile's @code{read} supports SRFI-62/R7RS\n"
"S-expression comments by default."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5203
msgid ""
"@node SRFI-64\n"
"@subsection SRFI-64 - A Scheme API for test suites.\n"
"@cindex SRFI-64"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5206
msgid ""
"See @uref{http://srfi.schemers.org/srfi-64/srfi-64.html, the\n"
"specification of SRFI-64}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5210
msgid ""
"@node SRFI-67\n"
"@subsection SRFI-67 - Compare procedures\n"
"@cindex SRFI-67"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5213
msgid ""
"See @uref{http://srfi.schemers.org/srfi-67/srfi-67.html, the\n"
"specification of SRFI-67}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5217
msgid ""
"@node SRFI-69\n"
"@subsection SRFI-69 - Basic hash tables\n"
"@cindex SRFI-69"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5225
msgid ""
"This is a portable wrapper around Guile's built-in hash table and weak\n"
"table support.  @xref{Hash Tables}, for information on that built-in\n"
"support.  Above that, this hash-table interface provides association\n"
"of equality and hash functions with tables at creation time, so\n"
"variants of each function are not required, as well as a procedure\n"
"that takes care of most uses for Guile hash table handles, which this\n"
"SRFI does not provide as such."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5227
msgid "Access it with:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5231
msgid ""
"@lisp\n"
"(use-modules (srfi srfi-69))\n"
"@end lisp"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5238
msgid ""
"@menu\n"
"* SRFI-69 Creating hash tables::  \n"
"* SRFI-69 Accessing table items::  \n"
"* SRFI-69 Table properties::    \n"
"* SRFI-69 Hash table algorithms::  \n"
"@end menu"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5241
msgid ""
"@node SRFI-69 Creating hash tables\n"
"@subsubsection Creating hash tables"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5245
msgid ""
"@deffn {Scheme Procedure} make-hash-table [equal-proc hash-proc #:weak "
"weakness start-size]\n"
"Create and answer a new hash table with @var{equal-proc} as the\n"
"equality function and @var{hash-proc} as the hashing function."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5249
msgid ""
"By default, @var{equal-proc} is @code{equal?}.  It can be any\n"
"two-argument procedure, and should answer whether two keys are the\n"
"same for this table's purposes."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5255
msgid ""
"My default @var{hash-proc} assumes that @code{equal-proc} is no\n"
"coarser than @code{equal?}  unless it is literally @code{string-ci=?}.\n"
"If provided, @var{hash-proc} should be a two-argument procedure that\n"
"takes a key and the current table size, and answers a reasonably good\n"
"hash integer between 0 (inclusive) and the size (exclusive)."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5258
msgid ""
"@var{weakness} should be @code{#f} or a symbol indicating how ``weak''\n"
"the hash table is:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5262
msgid ""
"@table @code\n"
"@item #f\n"
"An ordinary non-weak hash table.  This is the default."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5265
msgid ""
"@item key\n"
"When the key has no more non-weak references at GC, remove that entry."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5269
msgid ""
"@item value\n"
"When the value has no more non-weak references at GC, remove that\n"
"entry."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5274
msgid ""
"@item key-or-value\n"
"When either has no more non-weak references at GC, remove the\n"
"association.\n"
"@end table"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5280
msgid ""
"As a legacy of the time when Guile couldn't grow hash tables,\n"
"@var{start-size} is an optional integer argument that specifies the\n"
"approximate starting size for the hash table, which will be rounded to\n"
"an algorithmically-sounder number.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5285
msgid ""
"By @dfn{coarser} than @code{equal?}, we mean that for all @var{x} and\n"
"@var{y} values where @code{(@var{equal-proc} @var{x} @var{y})},\n"
"@code{(equal? @var{x} @var{y})} as well.  If that does not hold for\n"
"your @var{equal-proc}, you must provide a @var{hash-proc}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5295
msgid ""
"In the case of weak tables, remember that @dfn{references} above\n"
"always refers to @code{eq?}-wise references.  Just because you have a\n"
"reference to some string @code{\"foo\"} doesn't mean that an association\n"
"with key @code{\"foo\"} in a weak-key table @emph{won't} be collected;\n"
"it only counts as a reference if the two @code{\"foo\"}s are @code{eq?},\n"
"regardless of @var{equal-proc}.  As such, it is usually only sensible\n"
"to use @code{eq?} and @code{hashq} as the equivalence and hash\n"
"functions for a weak table.  @xref{Weak References}, for more\n"
"information on Guile's built-in weak table support."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5301
msgid ""
"@deffn {Scheme Procedure} alist->hash-table alist [equal-proc hash-proc #:"
"weak weakness start-size]\n"
"As with @code{make-hash-table}, but initialize it with the\n"
"associations in @var{alist}.  Where keys are repeated in @var{alist},\n"
"the leftmost association takes precedence.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5304
msgid ""
"@node SRFI-69 Accessing table items\n"
"@subsubsection Accessing table items"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5310
msgid ""
"@deffn {Scheme Procedure} hash-table-ref table key [default-thunk]\n"
"@deffnx {Scheme Procedure} hash-table-ref/default table key default\n"
"Answer the value associated with @var{key} in @var{table}.  If\n"
"@var{key} is not present, answer the result of invoking the thunk\n"
"@var{default-thunk}, which signals an error instead by default."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5315
msgid ""
"@code{hash-table-ref/default} is a variant that requires a third\n"
"argument, @var{default}, and answers @var{default} itself instead of\n"
"invoking it.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5319
msgid ""
"@deffn {Scheme Procedure} hash-table-set! table key new-value\n"
"Set @var{key} to @var{new-value} in @var{table}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5324
msgid ""
"@deffn {Scheme Procedure} hash-table-delete! table key\n"
"Remove the association of @var{key} in @var{table}, if present.  If\n"
"absent, do nothing.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5328
msgid ""
"@deffn {Scheme Procedure} hash-table-exists? table key\n"
"Answer whether @var{key} has an association in @var{table}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5333
msgid ""
"@deffn {Scheme Procedure} hash-table-update! table key modifier [default-"
"thunk]\n"
"@deffnx {Scheme Procedure} hash-table-update!/default table key modifier "
"default\n"
"Replace @var{key}'s associated value in @var{table} by invoking\n"
"@var{modifier} with one argument, the old value."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5338
msgid ""
"If @var{key} is not present, and @var{default-thunk} is provided,\n"
"invoke it with no arguments to get the ``old value'' to be passed to\n"
"@var{modifier} as above.  If @var{default-thunk} is not provided in\n"
"such a case, signal an error."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5343
msgid ""
"@code{hash-table-update!/default} is a variant that requires the\n"
"fourth argument, which is used directly as the ``old value'' rather\n"
"than as a thunk to be invoked to retrieve the ``old value''.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5346
msgid ""
"@node SRFI-69 Table properties\n"
"@subsubsection Table properties"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5351
msgid ""
"@deffn {Scheme Procedure} hash-table-size table\n"
"Answer the number of associations in @var{table}.  This is guaranteed\n"
"to run in constant time for non-weak tables.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5355
msgid ""
"@deffn {Scheme Procedure} hash-table-keys table\n"
"Answer an unordered list of the keys in @var{table}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5359
msgid ""
"@deffn {Scheme Procedure} hash-table-values table\n"
"Answer an unordered list of the values in @var{table}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5364
msgid ""
"@deffn {Scheme Procedure} hash-table-walk table proc\n"
"Invoke @var{proc} once for each association in @var{table}, passing\n"
"the key and value as arguments.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5371
msgid ""
"@deffn {Scheme Procedure} hash-table-fold table proc init\n"
"Invoke @code{(@var{proc} @var{key} @var{value} @var{previous})} for\n"
"each @var{key} and @var{value} in @var{table}, where @var{previous} is\n"
"the result of the previous invocation, using @var{init} as the first\n"
"@var{previous} value.  Answer the final @var{proc} result.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5376
msgid ""
"@deffn {Scheme Procedure} hash-table->alist table\n"
"Answer an alist where each association in @var{table} is an\n"
"association in the result.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5379
msgid ""
"@node SRFI-69 Hash table algorithms\n"
"@subsubsection Hash table algorithms"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5385
msgid ""
"Each hash table carries an @dfn{equivalence function} and a @dfn{hash\n"
"function}, used to implement key lookups.  Beginning users should\n"
"follow the rules for consistency of the default @var{hash-proc}\n"
"specified above.  Advanced users can use these to implement their own\n"
"equivalence and hash functions for specialized lookup semantics."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5390
msgid ""
"@deffn {Scheme Procedure} hash-table-equivalence-function hash-table\n"
"@deffnx {Scheme Procedure} hash-table-hash-function hash-table\n"
"Answer the equivalence and hash function of @var{hash-table}, respectively.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5398
msgid ""
"@deffn {Scheme Procedure} hash obj [size]\n"
"@deffnx {Scheme Procedure} string-hash obj [size]\n"
"@deffnx {Scheme Procedure} string-ci-hash obj [size]\n"
"@deffnx {Scheme Procedure} hash-by-identity obj [size]\n"
"Answer a hash value appropriate for equality predicate @code{equal?},\n"
"@code{string=?}, @code{string-ci=?}, and @code{eq?}, respectively.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5401
msgid ""
"@code{hash} is a backwards-compatible replacement for Guile's built-in\n"
"@code{hash}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5405
msgid ""
"@node SRFI-87\n"
"@subsection SRFI-87 => in case clauses\n"
"@cindex SRFI-87"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5409
msgid ""
"Starting from version 2.0.6, Guile's core @code{case} syntax supports\n"
"@code{=>} in clauses, as specified by SRFI-87/R7RS.\n"
"@xref{Conditionals}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5414
msgid ""
"@node SRFI-88\n"
"@subsection SRFI-88 Keyword Objects\n"
"@cindex SRFI-88\n"
"@cindex keyword objects"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5421
msgid ""
"@uref{http://srfi.schemers.org/srfi-88/srfi-88.html, SRFI-88} provides\n"
"@dfn{keyword objects}, which are equivalent to Guile's keywords\n"
"(@pxref{Keywords}).  SRFI-88 keywords can be entered using the\n"
"@dfn{postfix keyword syntax}, which consists of an identifier followed\n"
"by @code{:} (@pxref{Scheme Read, @code{postfix} keyword syntax}).\n"
"SRFI-88 can be made available with:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5425
msgid ""
"@example\n"
"(use-modules (srfi srfi-88))\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5429
msgid ""
"Doing so installs the right reader option for keyword syntax, using\n"
"@code{(read-set! keywords 'postfix)}.  It also provides the procedures\n"
"described below."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5434
msgid ""
"@deffn {Scheme Procedure} keyword? obj\n"
"Return @code{#t} if @var{obj} is a keyword.  This is the same procedure\n"
"as the same-named built-in procedure (@pxref{Keyword Procedures,\n"
"@code{keyword?}})."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5441
msgid ""
"@example\n"
"(keyword? foo:)         @result{} #t\n"
"(keyword? 'foo:)        @result{} #t\n"
"(keyword? \"foo\")        @result{} #f\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5446
msgid ""
"@deffn {Scheme Procedure} keyword->string kw\n"
"Return the name of @var{kw} as a string, i.e., without the trailing\n"
"colon.  The returned string may not be modified, e.g., with\n"
"@code{string-set!}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5451
msgid ""
"@example\n"
"(keyword->string foo:)  @result{} \"foo\"\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5454
msgid ""
"@deffn {Scheme Procedure} string->keyword str\n"
"Return the keyword object whose name is @var{str}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5459
msgid ""
"@example\n"
"(keyword->string (string->keyword \"a b c\"))     @result{} \"a b c\"\n"
"@end example\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5464
msgid ""
"@node SRFI-98\n"
"@subsection SRFI-98 Accessing environment variables.\n"
"@cindex SRFI-98\n"
"@cindex environment variables"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5467
msgid ""
"This is a portable wrapper around Guile's built-in support for \n"
"interacting with the current environment, @xref{Runtime Environment}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5474
msgid ""
"@deffn {Scheme Procedure} get-environment-variable name\n"
"Returns a string containing the value of the environment variable \n"
"given by the string @code{name}, or @code{#f} if the named \n"
"environment variable is not found.  This is equivalent to \n"
"@code{(getenv name)}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5479
msgid ""
"@deffn {Scheme Procedure} get-environment-variables\n"
"Returns the names and values of all the environment variables as an\n"
"association list in which both the keys and the values are strings.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5485
msgid ""
"@node SRFI-105\n"
"@subsection SRFI-105 Curly-infix expressions.\n"
"@cindex SRFI-105\n"
"@cindex curly-infix\n"
"@cindex curly-infix-and-bracket-lists"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5489
msgid ""
"Guile's built-in reader includes support for SRFI-105 curly-infix\n"
"expressions.  See @uref{http://srfi.schemers.org/srfi-105/srfi-105.html,\n"
"the specification of SRFI-105}.  Some examples:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5508
msgid ""
"@example\n"
"@{n <= 5@}                @result{}  (<= n 5)\n"
"@{a + b + c@}             @result{}  (+ a b c)\n"
"@{a * @{b + c@}@}           @result{}  (* a (+ b c))\n"
"@{(- a) / b@}             @result{}  (/ (- a) b)\n"
"@{-(a) / b@}              @result{}  (/ (- a) b) as well\n"
"@{(f a b) + (g h)@}       @result{}  (+ (f a b) (g h))\n"
"@{f(a b) + g(h)@}         @result{}  (+ (f a b) (g h)) as well\n"
"@{f[a b] + g(h)@}         @result{}  (+ ($bracket-apply$ f a b) (g h))\n"
"'@{a + f(b) + x@}         @result{}  '(+ a (f b) x)\n"
"@{length(x) >= 6@}        @result{}  (>= (length x) 6)\n"
"@{n-1 + n-2@}             @result{}  (+ n-1 n-2)\n"
"@{n * factorial@{n - 1@}@}  @result{}  (* n (factorial (- n 1)))\n"
"@{@{a > 0@} and @{b >= 1@}@}  @result{}  (and (> a 0) (>= b 1))\n"
"@{f@{n - 1@}(x)@}           @result{}  ((f (- n 1)) x)\n"
"@{a . z@}                 @result{}  ($nfx$ a . z)\n"
"@{a + b - c@}             @result{}  ($nfx$ a + b - c)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5513
msgid ""
"To enable curly-infix expressions within a file, place the reader\n"
"directive @code{#!curly-infix} before the first use of curly-infix\n"
"notation.  To globally enable curly-infix expressions in Guile's reader,\n"
"set the @code{curly-infix} read option."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5521
msgid ""
"Guile also implements the following non-standard extension to SRFI-105:\n"
"if @code{curly-infix} is enabled and there is no other meaning assigned\n"
"to square brackets (i.e. the @code{square-brackets} read option is\n"
"turned off), then lists within square brackets are read as normal lists\n"
"but with the special symbol @code{$bracket-list$} added to the front.\n"
"To enable this combination of read options within a file, use the reader\n"
"directive @code{#!curly-infix-and-bracket-lists}.  For example:"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5526
msgid ""
"@example\n"
"[a b]    @result{}  ($bracket-list$ a b)\n"
"[a . b]  @result{}  ($bracket-list$ a . b)\n"
"@end example"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5529
msgid "For more information on reader options, @xref{Scheme Read}."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5533
msgid ""
"@node SRFI-111\n"
"@subsection SRFI-111 Boxes.\n"
"@cindex SRFI-111"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5536
msgid ""
"@uref{http://srfi.schemers.org/srfi-111/srfi-111.html, SRFI-111}\n"
"provides boxes: objects with a single mutable cell."
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5541
msgid ""
"@deffn {Scheme Procedure} box value\n"
"Return a newly allocated box whose contents is initialized to\n"
"@var{value}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5545
msgid ""
"@deffn {Scheme Procedure} box? obj\n"
"Return true if @var{obj} is a box, otherwise return false.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5549
msgid ""
"@deffn {Scheme Procedure} unbox box\n"
"Return the current contents of @var{box}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5553
msgid ""
"@deffn {Scheme Procedure} set-box! box value\n"
"Set the contents of @var{box} to @var{value}.\n"
"@end deffn"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5555
msgid "@c srfi-modules.texi ends here"
msgstr ""

#: /home/bear/work/guile/doc/guile/en/srfi-modules.texi:5558
msgid ""
"@c Local Variables:\n"
"@c TeX-master: \"guile.texi\"\n"
"@c End:"
msgstr ""
